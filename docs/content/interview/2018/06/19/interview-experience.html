<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>The Interview Experience | Crab2Died Blog</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="The Interview Experience" />
<meta name="author" content="Crab2Died" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="一. JAVA基础 1. 9种基本数据类型及其封装类,所占大小" />
<meta property="og:description" content="一. JAVA基础 1. 9种基本数据类型及其封装类,所占大小" />
<link rel="canonical" href="https://crab2died.github.io/jekyll-blog/content/interview/2018/06/19/interview-experience.html" />
<meta property="og:url" content="https://crab2died.github.io/jekyll-blog/content/interview/2018/06/19/interview-experience.html" />
<meta property="og:site_name" content="Crab2Died Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-19T09:15:27+08:00" />
<script type="application/ld+json">
{"url":"https://crab2died.github.io/jekyll-blog/content/interview/2018/06/19/interview-experience.html","headline":"The Interview Experience","dateModified":"2018-06-19T09:15:27+08:00","datePublished":"2018-06-19T09:15:27+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://crab2died.github.io/jekyll-blog/content/interview/2018/06/19/interview-experience.html"},"author":{"@type":"Person","name":"Crab2Died"},"description":"一. JAVA基础 1. 9种基本数据类型及其封装类,所占大小","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/jekyll-blog/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://crab2died.github.io/jekyll-blog/feed.xml" title="Crab2Died Blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/jekyll-blog/">Crab2Died Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/jekyll-blog/about.html">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">The Interview Experience</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-06-19T09:15:27+08:00" itemprop="datePublished">Jun 19, 2018
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Crab2Died</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="一-java基础">一. JAVA基础</h2>
<h3 id="1-9种基本数据类型及其封装类所占大小">1. 9种基本数据类型及其封装类,所占大小</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">类型</th>
      <th style="text-align: center">包装类</th>
      <th style="text-align: center">大小(字节)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">byte</td>
      <td style="text-align: center">Byte</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">char</td>
      <td style="text-align: center">Character</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">short</td>
      <td style="text-align: center">Short</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">int</td>
      <td style="text-align: center">Integer</td>
      <td style="text-align: center">4</td>
    </tr>
    <tr>
      <td style="text-align: center">float</td>
      <td style="text-align: center">Float</td>
      <td style="text-align: center">4</td>
    </tr>
    <tr>
      <td style="text-align: center">double</td>
      <td style="text-align: center">Double</td>
      <td style="text-align: center">8</td>
    </tr>
    <tr>
      <td style="text-align: center">long</td>
      <td style="text-align: center">Long</td>
      <td style="text-align: center">8</td>
    </tr>
    <tr>
      <td style="text-align: center">boolean</td>
      <td style="text-align: center">Boolean</td>
      <td style="text-align: center">-</td>
    </tr>
    <tr>
      <td style="text-align: center">void</td>
      <td style="text-align: center">Void</td>
      <td style="text-align: center">-</td>
    </tr>
  </tbody>
</table>

<h3 id="2-object类方法">2. Object类方法</h3>
<ul>
  <li>getClass() 获取类对象Class (native)</li>
  <li>hashCode() 获取hashCode值(native)</li>
  <li>equals(Object) 判断是否同一对象</li>
  <li>clone() 对象克隆(native)</li>
  <li>wait()</li>
  <li>wait(timeout)</li>
  <li>wait(timeout, nanos)</li>
  <li>notify()</li>
  <li>notifyAll()</li>
  <li>toString()</li>
  <li>finalize() (protected)</li>
</ul>

<h3 id="3-equals-hashcode-比较">3. equals 、hashCode、== 比较</h3>
<ul>
  <li>equals是Object类方法，内部实现的是判断对象是否相等(即 ==)。</li>
  <li>hashCode是Object的native方法，返回的是类似表示对象地址的整数。</li>
  <li>==是判断2个对象是否相同。</li>
  <li>如果2个对象相同则hashCode一定相等，若2个对象不同hashCode不一定相等。</li>
  <li>一般地重写了equals方法建议也要重写hashCode方法。</li>
</ul>

<h3 id="4-面向对象的特性与含义">4. 面向对象的特性与含义</h3>
<ul>
  <li><strong>抽象</strong>  是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不
关注这些行为的细节是什么。</li>
  <li><strong>封装</strong>  是指将某事物的属性和行为包装到对象中，这个对象只对外公布需要公开的属性和行为，而这个公布也是可以有选择性的公布
给其它对象，private、protected、public三种修饰符或不用(即默认default)对外部对象访问该对象的属性和行为进行限制。</li>
  <li><strong>继承</strong>  是子对象可以继承父对象的属性和行为，亦即父对象拥有的属性和行为，其子对象也就拥有了这些属性和行为。</li>
  <li><strong>多态</strong>  是指父对象中的同一个行为能在其多个子对象中有不同的表现。也就是说子对象可以使用重写父对象中的行为,使其拥有不同于
     父对象和其它子对象的表现,这就是overriding(重写)。实现多态的技术称为：动态绑定(dynamic binding)，是指在执行期间判
断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</li>
</ul>

<h3 id="5-override与overload">5. Override与Overload</h3>
<ul>
  <li><strong>Override</strong>是重写:方法名称、参数个数，类型，顺序，返回值类型都是必须和父类方法一致的。它的关系是父子关系。</li>
  <li><strong>Overload</strong>是重载:方法名称不变，方法参数个数、类型、顺序至少一个不同。它的关系是同一个类，同一个方法名。</li>
</ul>

<h3 id="6-wait与sleep">6. wait与sleep</h3>
<ul>
  <li>wait是Object类的方法；而sleep是Thread类的静态方法。</li>
  <li>当线程执行到wait方法时，他就会进入到该对象相关的等待池中，同时释放对象的机锁，其他线程可访问，直到超时或该对象调用notify
或notifyAll；而当线程执行sleep方法时，线程进入阻塞状态，让出CPU资源，但在Synchronized同步块中不能释放对象的锁。</li>
  <li>wait方法必须放在synchronized代码块中，否则会在时抛出<code class="highlighter-rouge">java.lang.IllegalMonitorStateException</code>异常。</li>
  <li>wait和sleep都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException(但不建议使用该方法)。</li>
</ul>

<h3 id="7-java并发">7. java并发</h3>
<ul>
  <li><a href="/jekyll-blog/content/java/2018/06/15/java-concurrent.html">java并发编程</a></li>
</ul>

<h3 id="8-interface与abstract类">8. interface与abstract类</h3>
<ul>
  <li>抽象类是包含有抽象方法的类(也可以拥有成员变量和普通成员方法)，抽象方法是只有方法声明没有具体实现的方法，所以抽象类不能实例化，是为
了继承而存的，抽象类与普通类有3点区别：
    <ul>
      <li>1.抽象方法必须是public或protected，缺损情况下默认为public;</li>
      <li>2.抽象类不能被实例化；</li>
      <li>3.如果一个类继承了抽象类，则子类必须实现父类的抽象方法，若没有实现父类抽象方法，则子类也必须定义为抽象类。</li>
    </ul>
  </li>
  <li>接口是泛指供别人调用的方法或函数，接口中可以有变量和方法，变量被隐式地指定为<code class="highlighter-rouge">public static final</code>，方法被隐式地指定为
<code class="highlighter-rouge">public abstract</code>,接口中的方法不能有具体的实现(JDK8之后接口可以有default方法)。</li>
  <li>接口与抽象类比较:
    <ul>
      <li>1.语法层面上:
        <ul>
          <li>1).抽象类可以提供成员方法的实现细节而接口中只能存在public abstract方法</li>
          <li>2).抽象类中的成员变量可以是各种类型，而接口中的成员变量只能是public static final类型</li>
          <li>3).接口中不能存在静态代码块和静态方法，而抽象类中可以</li>
          <li>4).一个类只能继承一个抽象类而可以实现多个接口</li>
        </ul>
      </li>
      <li>2.设计层面上:
        <ul>
          <li>1).抽象类是对一种事物对象的抽象，而接口是对事物行为的抽象，抽象类是对整个类整体的抽象，包括属性、行为，而接口是对类的局部
(行为)的抽象。继承抽象类是”是不是”的关系，实现接口是”有没有”的关系。</li>
          <li>2).设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计，而接口是一种行为规范，它是一种辐射式设计</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="9-fail-fast">9. fail-fast</h3>
<ul>
  <li>fail-fast：机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。
例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出异常: 
<code class="highlighter-rouge">ConcurrentModificationException</code>，产生fail-fast事件。</li>
</ul>

<h3 id="10-jdk和cglib动态代理">10. JDK和CGLIB动态代理</h3>
<ul>
  <li>JDK动态代理只能针对实现了接口的类生成代理(实例化一个类)。此时代理对象和目标对象实现了相同的接口，目标对象作为代理对象的一个属性，
具体接口实现中，可以在调用目标对象相应方法前后加上其他业务处理逻辑。</li>
  <li>CGLIB是针对类实现代理，主要是对指定的类生成一个子类(没有实例化一个类)，覆盖其中的方法。</li>
</ul>

<h2 id="jvm">JVM</h2>
<h3 id="1-内存模型">1. 内存模型</h3>
<ul>
  <li><strong>堆内存(Heap)</strong> 是线程间共享内存，主要存放java的对象及数组</li>
  <li><strong>栈内存(Stack)</strong> 是线程间不共享的，主要存放基本数据类型和对象及数组的引用等</li>
  <li><strong>方法区(Method Area)</strong> 是存储已被虚拟机加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据</li>
  <li><strong>本地方法栈(Native Method Stack)</strong> 为虚拟机调用本地Native方法提供服务,有的虚拟机与虚拟机栈合二为一</li>
  <li><strong>程序计数器(Program Counter Register)</strong> 是当前虚拟机执行指令的地址，当执行到Native方法时其值为空(Undefined)</li>
  <li><strong>运行时常量池(Runtime Constant Pool)</strong> 用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放</li>
  <li><strong>直接内存(Direct Memory)</strong> NIO的DirectByteBuffer对象使用直接内存,这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据</li>
</ul>

<h3 id="2-gc的2种判定方法">2. GC的2种判定方法</h3>
<ul>
  <li><strong>引用计数</strong>: 实现简单、高效，但会出现循环引用的时候对象将无法得到回收</li>
  <li><strong>引用链</strong>：即可达性分析，以GC Roots为根节点开始向下搜索，所走的路径叫做引用链(Reference Chain)，当一个对象到GC Roots对象没有
任何引用链时说明该对象不可用，可作为GC Roots的对象：
    <ul>
      <li>1.虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
      <li>2.方法区中的类静态属性引用的对象或者常量引用的对象。</li>
      <li>3.本地方法栈中JNI（就是native方法）引用的对象。</li>
    </ul>
  </li>
</ul>

<h3 id="3-java自动内存管理">3. java自动内存管理</h3>
<ul>
  <li><a href="/jekyll-blog/content/java/2018/06/15/java-gc.html">java自动内存管理</a></li>
</ul>

<h2 id="其他">其他</h2>
<h3 id="1-osi网络模型">1. OSI网络模型</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">层级</th>
      <th style="text-align: left">名称</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: left">应用层</td>
      <td style="text-align: left">指网络操作系统和具体的应用程序，对应WWW服务器、FTP服务器等应用软件</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: left">表示层</td>
      <td style="text-align: left">数据语法的转换、数据的传送等</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: left">会话层</td>
      <td style="text-align: left">建立起两端之间的会话关系，并负责数据的传送</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: left">传输层</td>
      <td style="text-align: left">负责错误的检查与修复，以确保传送的质量，是TCP/UDP工作的地方。（报文）</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: left">网络层</td>
      <td style="text-align: left">提供了编址方案,IP协议工作的地方(数据包）</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: left">数据链路层</td>
      <td style="text-align: left">将由物理层传来的未经处理的位数据包装成数据帧</td>
    </tr>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: left">物理层</td>
      <td style="text-align: left">对应网线、网卡、接口等物理设备(位)</td>
    </tr>
  </tbody>
</table>

<h3 id="2-tcpip协议">2. TCP/IP协议</h3>
<ul>
  <li>应用层</li>
  <li>传输层</li>
  <li>网络层</li>
  <li>链路层</li>
</ul>

<h3 id="3-ip分类">3. IP分类</h3>
<ul>
  <li>A类地址（1.0.0.0-126.255.255.255）用于最大型的网络，该网络的节点数可达16,777,216个。</li>
  <li>B类地址（128.0.0.0-191.255.255.255）用于中型网络，节点数可达65,536个。</li>
  <li>C类地址（192.0.0.0-223.255.255.255）用于256个节点以下的小型网络的单点网络通信。</li>
  <li>D类地址（224.0.0.0-239.255.255.255）并不反映网络的大小，只是用于组播，用来指定所分配的接收组播的节点组，这个节点组由组播订
阅成员组成。D类地址的范围为</li>
  <li>E类（240.0.0.0-255.255.255.254）地址用于试验。</li>
</ul>

<h3 id="4-tcp与udp">4. TCP与UDP</h3>
<ul>
  <li>TCP、UDP都是传输层协议</li>
  <li>TCP(Transmission Control Protocol, 传输控制协议) 是面向连接的协议(即在收发数据前必须和对方建立可靠连接)，TCP建立连接要3次
握手，TCP断开连接需要4次挥手，保证了数据通信的可靠性；TCP包头最小长度为20个字节数。</li>
  <li>UDP(User Data Protocol, 用户数据报协议) 是一个非连接的协议(即传输数据之前源端和终端不建立连接)，只是简单的把应用程序的数据
尽快地扔到网络上，因此UDP传输速度只受应用程序生成数据速度、计算机的能力和传输带宽的限制，接收端，UDP把每个消息段放入队列中
应用程序读取使用；UDP可以一台服务器同时向多台客户机传输相同数据；UDP消息头很短只有8个字节；UDP尽可能快的发送数据，但不保证
数据的可靠性(丢包，顺序等)；UDP是面向报文的，发送方的报文只是添加首部后就向下交付给IP层，既不拆分也不合并，这些需要接收端
应用程序自己实现。</li>
</ul>

<h3 id="5-死锁的必要条件">5. 死锁的必要条件</h3>
<ul>
  <li><strong>互斥条件</strong>：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源
被另一进程占有时，则申请者等待直到资源被占有者释放。</li>
  <li><strong>不可剥夺条件</strong>：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。</li>
  <li><strong>请求和保持条件</strong>：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。</li>
  <li><strong>循环等待条件</strong>：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有
的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。</li>
</ul>

<h3 id="6-mysql索引55之前默认myisam引擎55之后默认innodb">6. MySQL索引(5.5之前默认MyISAM引擎，5.5之后默认InnoDB)</h3>
<ul>
  <li>MyISAM使用B-Tree实现主键索引、唯一索引和非主键索引。</li>
  <li>InnoDB中非主键索引使用的是B-Tree数据结构，而主键索引使用的是B+Tree。</li>
</ul>

<h3 id="7-进程与线程">7. 进程与线程</h3>
<ul>
  <li>进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元</li>
  <li>同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。</li>
  <li>进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进
程中的其他线程的结束</li>
  <li>线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的</li>
  <li>线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源</li>
  <li>线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标
示一个进程或一个线程的标志</li>
</ul>

<h3 id="8-ipc通信方式">8. IPC通信方式</h3>
<ul>
  <li><strong>管道(Pipe)</strong>：匿名管道（pipe亲缘关系的进程通信）、命名管道（mkfifo/mknod）</li>
  <li><strong>消息队列</strong>：是基于消息的、用无亲缘关系的进程间通信，主要函数：msgget、msgsend、msgrecv、msgctl</li>
  <li><strong>信号量</strong>：相当于一把互斥锁，通过p、v操作，主要函数：semget、semop、semctl</li>
  <li><strong>共享内存</strong>：是进程间通信速度最快的，所以用经常是集合信号量或互斥锁来实现同步，shmget、shmat、shmdt、shmctl</li>
</ul>

<h3 id="9-虚拟内存">9. 虚拟内存</h3>
<ul>
  <li>是将进程部分装入内存中，从而能实现一个很大的程序能在一个比它小的内存中运行，它的主要实现是靠程序的换进换出来实现的，因为内存
中0-3G是用户使用，3-4G才是内存使用，通过映射来实现来进行逻辑地址到物理地址的映射</li>
</ul>

<h3 id="10-设计原则">10. 设计原则</h3>
<ul>
  <li>依赖倒置原则－Dependency Inversion Principle (DIP)</li>
  <li>里氏替换原则－Liskov Substitution Principle (LSP)</li>
  <li>接口分隔原则－Interface Segregation Principle (ISP)</li>
  <li>单一职责原则－Single Responsibility Principle (SRP)</li>
  <li>开闭原则－The Open-Closed Principle (OCP)</li>
</ul>

  </div><a class="u-url" href="/jekyll-blog/content/interview/2018/06/19/interview-experience.html" hidden></a>

</article>

<hr style="height:8px; border: none; border-top: 8px ridge rgba(0,0,0,0.21);" />


<!--<div id="disqus_thread"></div>-->
<!--<script>-->

<!--/**-->
<!--*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.-->
<!--*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/-->
<!--/*-->
<!--var disqus_config = function () {-->
<!--this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable-->
<!--this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable-->
<!--};-->
<!--*/-->
<!--(function() { // DON'T EDIT BELOW THIS LINE-->
<!--var d = document, s = d.createElement('script');-->
<!--s.src = 'https://crab2died.disqus.com/embed.js';-->
<!--s.setAttribute('data-timestamp', +new Date());-->
<!--(d.head || d.body).appendChild(s);-->
<!--})();-->
<!--</script>-->
<!--<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>-->

<div id="container"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    var gitment = new Gitment({
        id: 'The Interview Experience', // 可选。默认为 location.href
        owner: 'Crab2Died',
        repo: 'crab2died.github.io',
        oauth: {
            client_id: '2117b548bf34c40984be',
            client_secret: '2642328e6056dbf7b02951961e5ca481406410ed',
        },
    });
    gitment.render('container')
</script>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/jekyll-blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Crab2Died Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Copyright ©2018 Crab2Died</li><li><a class="u-email" href="mailto:Crab2Died@126.com">Crab2Died@126.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Crab2Died"><svg class="svg-icon"><use xlink:href="/jekyll-blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Crab2Died</span></a></li><li><a href="/jekyll-blog/feed.xml"><svg class="svg-icon"><use xlink:href="/jekyll-blog/assets/minima-social-icons.svg#rss"></use></svg> <span>via RSS</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Crab2Died&#39;s personal blog website.</p>
      </div>
    </div>

  </div>
<script>
    // baidu tongji
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?669141ef93f4209be04bb674c56cba17";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>
</footer>
</body>

</html>
