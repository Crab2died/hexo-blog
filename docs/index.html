<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Crab2Died Blog | Crab2Died’s personal blog website.</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="Crab2Died Blog" />
<meta name="author" content="Copyright ©2018 Crab2Died" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Crab2Died’s personal blog website." />
<meta property="og:description" content="Crab2Died’s personal blog website." />
<link rel="canonical" href="https://crab2died.github.io/jekyll-blog/" />
<meta property="og:url" content="https://crab2died.github.io/jekyll-blog/" />
<meta property="og:site_name" content="Crab2Died Blog" />
<link rel="next" href="https://crab2died.github.io/jekyll-blog/content/page/2" />
<script type="application/ld+json">
{"url":"https://crab2died.github.io/jekyll-blog/","headline":"Crab2Died Blog","author":{"@type":"Person","name":"Copyright ©2018 Crab2Died"},"name":"Crab2Died Blog","description":"Crab2Died’s personal blog website.","@type":"WebSite","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/jekyll-blog/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://crab2died.github.io/jekyll-blog/feed.xml" title="Crab2Died Blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/jekyll-blog/">Crab2Died Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/jekyll-blog/about.html">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home"><h2 class="post-list-heading">Blogs</h2>
    <ul class="post-list"><li><span class="post-meta">Jun 19, 2018</span>
            <h3>
                <a class="post-link" href="/jekyll-blog/content/interview/2018/06/19/interview-experience.html">
                    The Interview Experience
                </a><span class="post-tag"><strong>Java</strong></span><span class="post-tag"><strong>Interview</strong></span><span class="post-tag"><strong>Experience</strong></span></h3>

            <div class="post-excerpt text-snapshot">一. JAVA基础
1. 9种基本数据类型及其封装类,所占大小

</div>
        </li><li><span class="post-meta">Jun 18, 2018</span>
            <h3>
                <a class="post-link" href="/jekyll-blog/content/database/2018/06/18/database.html">
                    Database
                </a><span class="post-tag"><strong>Database</strong></span></h3>

            <div class="post-excerpt text-snapshot">一. 四大特性(CIAD)

  原子性(Atomicity): 要么全成功，要么全失败，失败会回滚。
  一致性(Consistency): 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执
行之前和执行之后都必须处于一致性状态。
  隔离性(Isolation): 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，
不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
  持久性(Durability): 一旦事物提交成功，那么数据库中的数据就是永久改变的，即使系统故障也不会丢失提交的事物。


二. 数据库隔离级别
1. 不考虑隔离级别造成的问题

  更新丢失: 2个事物同时更新一条数据会有一个事物把另一个事物的更新覆盖了，这是因为系统没有任何操作隔离导致的.
  脏读: 一个事物读取了另一个事物还未提交事物的数据
  不可重复读: 一个事务对同一行数据重复读取两次，但是却得到了不同的结果
    
      虚读: 一个事物去改变数据改变后发现还有数据为按要求改变，是因为另一事物也做了改变的缘故
      幻读: 同一个事物内多次查询返回的结果不一致，是因为另一事物对数据进行了改变
    
  


2. 隔离级别(低 -&gt; 高)

  Read uncommitted(未授权读取、读未提交)
    
      当一个事物在执行写操作时，则不允许另一事物执行写操作，可执行其他操作，可由排他锁来实现
      解决了更新丢失问题，但会出现脏读
    
  
  Read committed(授权读取、读提交)
    
      读取数据事物允许其他事物继续访问该数据，但未提交的数据禁止其他事物访问
      避免了脏读，但可能会出现幻读
    
  
  Repeatable read(可重复读取)
    
      读数据的事物将禁止写事物(可以读事物),写事物将禁止所有其他事物
      避免了脏读和不可重复读，但可能会出现幻读
    
  
  Serializable(序列化)
    
      事物严格按照顺序一个一个执行
      能避免所有情况，但会极大影响系统性能
    
  


3. 扩展

  大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。
  Mysql的默认隔离级别就是Repeatable read。
  MySQL数据库隔离级别管理
    
      查看隔离级别: select @@tx_isolation
      修改隔离级别:  
set [glogal | session] transaction isolation level 隔离级别名称
如set transaction isolation level read-committed
或者
set tx_isolation='隔离级别名称' 如 set tx_isolation = 'read-committed'
    
  
  隔离级别的设置只对当前连接有效


</div>
        </li><li><span class="post-meta">Jun 17, 2018</span>
            <h3>
                <a class="post-link" href="/jekyll-blog/content/java/2018/06/17/java-compile-and-optimize.html">
                    Java Compile and Optimize
                </a><span class="post-tag"><strong>Java</strong></span><span class="post-tag"><strong>JIT</strong></span><span class="post-tag"><strong>Optimize</strong></span></h3>

            <div class="post-excerpt text-snapshot">1. 早期(编译期)优化
1-1. 概论

  前端编译器:Sun的Javac、 Eclipse JDT中的增量式编译器(ECJ)
    
      JIT编译器:HotSpot VM的C1、 C2编译器
      AOT编译器:GNU Compiler for the Java(GCJ)、 Excelsior JET
    
  
  javac这类编译器几乎不对代码进行性能优化,把性能优化放到了JIT即时编译器内,可为JRuby、
Groovy这类语言的代码也同等享有优化带来的好处


1-2. javac编译
1-2.1. 编译过程

  解析与填充符号表过程
    
      词法、语法分析
        
          词法分析是将源代码的字符流转变为标记(Token)集合,单个字符是程序编写过程的最小元素,而标记则是编译过程的最小元素,关键字、 变量名、 字面量、 运算符都可以成为标记
          语法分析是根据Token序列构造抽象语法树的过程,抽象语法树(Abstract Syntax Tree,AST)是一种用来描述程序代码语法结构的树形表示方式,语法树的每一个节点都代表着程序
代码中的一个语法结构(Construct),例如包、 类型、 修饰符、 运算符、 接口、 返回值甚至代码注释等都可以是一个语法结构.
        
      
      填充符号表
        
          符号表(Symbol Table)是由一组符号地址和符号信息构成的表格
          在语义分析中,符号表所登记的内容将用于语义检查(如检查一个名字的使用和原先的说明是否一致)和产生中间代码.在目标代码生成阶段,当对符号名进行地址分配时,符号表是地址分配的依据.
        
      
    
  
  插入式注解处理器的注解处理过程
  分析与字节码生成过程
    
      标注检查
        
          检查的内容包括诸如变量使用前是否已被声明、 变量与赋值之间的数据类型是否能够匹配等
          常量折叠 如定义了 int a = 1 + 2 会被编译为 int a = 3
        
      
      数据及控制流分析
        
          数据及控制流分析是对程序上下文逻辑更进一步的验证,它可以检查出诸如程序局部变量在使用前是否有赋值、
 方法的每条路径是否都有返回值、 是否所有的受查异常都被正确处理了等问题.
        
      
      语法糖
        
          语法糖:也称糖衣语法,是由英国计算机科学家彼得·约翰·兰达(Peter J.Landin)发明的一个术语,
 指在计算机语言中添加的某种语法,这种语法对语言的功能并没有影响,但是更方便程序员使用.
 通常来说,使用语法糖能够增加程序的可读性,从而减少程序代码出错的机会.
          java语法糖:泛型、变长参数、 自动装箱/拆箱等 内部类、 枚举类、 断言语句、 对枚举和字符串(在JDK 1.7中支持)
 的switch支持、 try语句中定义和关闭资源(在JDK 1.7中支持)等
          泛型:编译器会进行解泛,所以泛型不能进行方法重载
          自动装箱、 拆箱与遍历循环
          条件编译 if 的条件为常量时编译期会被执行
        
      
      字节码生成
        
          字节码生成阶段不仅仅是把前面各个步骤所生成的信息(语法树、 符号表)转化成字节码写到磁盘中,
 编译器还进行了少量的代码添加和转换工作.
        
      
    
  


2. 晚期(运行期)优化
2-1. 即时编译器(JIT)

  为了提高热点代码的执行效率,在运行时,虚拟机将会把这些代码编译成与本地平台相关的机器码,并进行各种层次的优化,
完成这个任务的编译器称为即时编译器(Just In Time Compiler)
  解释器与编译器(sun HotSpot虚拟机为例)
    
      交互模型
             |---------------即时编译-----------↓
     ↓                         Client Compiler(C1编译器)
  解释器(Interpreter)               编译器
     ↑                         Server Compiler(C2编译器)
     |----------------逆优化------------↑
        
      
      HotSpot虚拟机同时由解释器与编译器搭配使用(成为混合模式(Mixed Model)),
可添加参数-Xint强制虚拟机使用解释模式(Interpreted Mode),可添加参数-Xcomp强制虚拟机使用编译模式(Compiled Mode)
      启动参数-client启用Client Compiler编译器 参数-server启用Server Compiler编译器
      HotSpot虚拟机还会逐渐启用分层编译(Tiered Compilation)的策略,分层编译的概念在JDK 1.6时期出现,
JDK1.7中Server模式中默认开启,之前需配参数-XX:+TieredCompilation启用
    
  
  编译对象与触发条件
    
      触发条件
        
          被多次调用的方法
          被多次执行的循环体,这个称为栈上替换(On Stack Replacement,简称为OSR编译)
        
      
      热点代码判定
        
          基于采样的热点探测,周期性检测个线程的栈顶,若某个方法经常在栈顶,则认为是热点方法；
 优点是实现简单简单,高效,容易获取方法调用关系,缺点是不能准确判定一个方法的热度
          基于计数器的热点探测,虚拟机为每个方法设定计数器,统计方法执行次数,若超过一定阈值则认为是热点方法；
 优点是能准确判定一个方法的热度,缺点是要为每个方法建立计数器并维护,实现麻烦,也不能获取方法的调用关系
        
      
      HotSpot虚拟机是基于计数器的热点探测,有2个计数器:方法调用计数器(Invocation Counter)和回边计数器(Back Edge Counter)
        
          方法调用计数器,Client模式下阈值为1500次,Server模式下阈值为1000次,可由参数-XX:CompileThreshold来设置
 -XX:-UseCounterDecay设置关闭热度衰减,-XX:CounterHalfLifeTime参数设置半衰周期的时间,单位是秒
          回边计数器,参数-XX:OnStackReplacePercentage来间接调整回边计数器的阈值
 Client模式下阈值计算公式:
 方法调用计数器阈值(CompileThreshold)×OSR比率(OnStackReplacePercentage)[默认值为933]/100 默认情况下为13995
 Server模式下阈值计算公式:
 方法调用计数器阈值(CompileThreshold)×(OSR比率(OnStackReplacePercentage)[默认值140]-解释器监控比率(InterpreterProfilePercentage)[默认值33]/100 
 默认情况下为10700
        
      
    
  
  编译过程
    
      Client模式下编译过程
 
      Server模式下编译过程
 相当复杂
    
  
  优化技术
    
      公共子表达式消除
        
          经典优化技术,如果一个表达式E已经计算过了,并且从先前的计算到现在E中所有变量的值都没有发生变化,
 那么E的这次出现就成为了公共子表达式. 对于这种表达式,没有必要花时间再对它进行计算,只需要直接用前面计算过的表达式结果代替E就可以了
        
      
      数组边界检查消除
        
          语言相关的其他消除操作还有不少,如自动装箱消除(Autobox Elimination)、 安全点消除(Safepoint Elimination)、消除反射(Dereflection)等
        
      
      方法内联
        
          虚拟机最重要的优化手段之一,除了消除方法调用的成本之外,它更重要的意义是为其他优化手段建立良好的基础
          非虚方法直接内联,虚方法引入了一种名为“类型继承关系分析”(Class Hierarchy Analysis,CHA)的技术,
 检查发现没有多个目标版本可供选择,则也可内联,但需准备一个逃生门,即使有多个版本目标也会默认内联,但在调用时要检查,
 发现版本目标不一致在取消内联,会从“逃生门”回到解释状态重新执行
        
      
      逃逸分析(JDK1.6)
        
          当下java最前沿的优化技术
          逃逸分析的基本行为就是分析对象动态作用域:当一个对象在方法中被定义后,它可能被外部方法所引用,
 例如作为调用参数传递到其他方法中,称为方法逃逸. 甚至还有可能被外部线程访问到,
 譬如赋值给类变量或可以在其他线程中访问的实例变量,称为线程逃逸.
          栈上分配(Stack Allocation),如果证明一个对象不会逃逸到方法之外,则可以将对象分配到方法栈帧内存,这样随着栈帧出栈而销毁,极大地降低了GC系统压力
          同步消除(Synchronization Elimination),如果能证明一个变量不会逃逸出线程,那就可以消除掉同步措施,消除同步带来的消耗
          标量替换(Scalar Replacement)
 标量(Scalar),是指一个数据已经无法再分解成更小的数据来表示了,如:int,long,double等
 聚合量(Aggregate),是指一个数据可以被分解,典型的java对象
 如果证明一个对象不被外界访问,又可拆散的话,那程序在调用的时候就不创建该变量,改为创建多个成员变量来代替,
 将对象拆分后,除了可以让对象的成员变量在栈上(栈上存储的数据,有很大的概率会被虚拟机分配至物理机器的高速寄存器中存储)
 分配和读写之外,还可以为后续进一步的优化手段创建条件
          逃逸分析尚不成熟
        
      
    
  

</div>
        </li><li><span class="post-meta">Jun 15, 2018</span>
            <h3>
                <a class="post-link" href="/jekyll-blog/content/java/2018/06/15/java-gc.html">
                    Java GC
                </a><span class="post-tag"><strong>Java</strong></span><span class="post-tag"><strong>GC</strong></span></h3>

            <div class="post-excerpt text-snapshot">一. Java虚拟机内存区域
1. 运行时数据区


</div>
        </li><li><span class="post-meta">Jun 15, 2018</span>
            <h3>
                <a class="post-link" href="/jekyll-blog/content/java/2018/06/15/java-concurrent.html">
                    Java Concurrent
                </a><span class="post-tag"><strong>Java</strong></span><span class="post-tag"><strong>Concurrent</strong></span></h3>

            <div class="post-excerpt text-snapshot">1. JAVA与线程
1.1 线程的实现

  实现方式:使用内核线程实现、 使用用户线程实现和使用用户线程加轻量级进程混合实现.
  JDK1.2之前是基于用户线程实现的，JDK1.2及以后是基于操作系统原生线程模型实现的.


1.2 Java线程调度

  线程调度是指系统为线程分配处理器使用权的过程,主要调度方式有两种,分别是协同式线程调度(Cooperative Threads-Scheduling)
和抢占式线程调度(Preemptive ThreadsScheduling)
  协同式线程调度:线程的执行时间由线程本身来控制,线程把自己的工作执行完了之后,要主动通知系统切换到另外一个线程上;
优点是实现简单,缺点是线程执行时间不可控制,容易线程阻塞
  每个线程将由系统来分配执行时间,线程的切换不由线程本身来决定(在Java中,Thread.yield()可以让出执行时间,但是要获取执行时
间的话,线程本身是没有什么办法的);优点是线程的执行时间是系统可控的,也不会有一个线程导致整个进程阻塞的问题.
  JAVA线程有10个优先级(Thread.MIN_PRIORITY至Thread.MAX_PRIORITY)


1.3 线程转换状态

  JAVA线程定义了6个状态:
    
      新建(New):创建后尚未启动的线程处于这种状态.
      运行(Runable):Runable包括了操作系统线程状态中的Running和Ready,也就是处于此状态的线程有可能正在执行,也有可能正在
等待着CPU为它分配执行时间.
      无限期等待(Waiting):处于这种状态的线程不会被分配CPU执行时间,它们要等待被
    其他线程显式地唤醒. 以下方法会让线程陷入无限期的等待状态:
    ● 没有设置Timeout参数的Object.wait()方法.
    ● 没有设置Timeout参数的Thread.join()方法.
    ● LockSupport.park()方法.
      限期等待(Timed Waiting):处于这种状态的线程也不会被分配CPU执行时间,不过无须等待被其他线程显式地唤醒,在一定时间之后
它们会由系统自动唤醒. 以下方法会让线程进入限期等待状态:
    ● Thread.sleep()方法.
    ● 设置了Timeout参数的Object.wait()方法.
    ● 设置了Timeout参数的Thread.join()方法.
    ● LockSupport.parkNanos()方法.
    ● LockSupport.parkUntil()方法
      阻塞(Blocked):该状态程序在等待获取一个排他锁，程序在同步时会在该状态
      结束(Terminated):已终止线程的线程状态,线程已经结束执行.
    
  
  线程状态转换关系图



2. 线程安全与锁优化
2.1 JAVA中的线程安全

  共享数据分类
    
      不可变(Immutable):不可变对象一定是线程安全的,典型的final
      绝对线程安全:
      相对线程安全: java大部分的线程安全都是相对线程安全的
      线程兼容:
      线程对立:
    
  


</div>
        </li></ul>

    <!-- 分页链接 -->
    
    <div class="pagination">
        
        <span class="page-content">&laquo; Prev</span>
        

        
        
        <em class="page-content">1</em>
        
        
        
        <a class="page-content" href="/jekyll-blog/content/page/2">2</a>
        
        

        
        <a class="page-content" href="/jekyll-blog/content/page/2">Next &raquo;</a>
        
    </div>
    </div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/jekyll-blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Crab2Died Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Copyright ©2018 Crab2Died</li><li><a class="u-email" href="mailto:Crab2Died@126.com">Crab2Died@126.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Crab2Died"><svg class="svg-icon"><use xlink:href="/jekyll-blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Crab2Died</span></a></li><li><a href="/jekyll-blog/feed.xml"><svg class="svg-icon"><use xlink:href="/jekyll-blog/assets/minima-social-icons.svg#rss"></use></svg> <span>via RSS</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Crab2Died&#39;s personal blog website.</p>
      </div>
    </div>

  </div>
<script>
    // baidu tongji
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?669141ef93f4209be04bb674c56cba17";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>
</footer>
</body>

</html>
