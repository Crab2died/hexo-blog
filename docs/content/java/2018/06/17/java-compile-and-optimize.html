<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Java Compile and Optimize | Crab2Died</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="Java Compile and Optimize" />
<meta name="author" content="Crab2Died" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1. 早期(编译期)优化 1-1. 概论 前端编译器:Sun的Javac、 Eclipse JDT中的增量式编译器(ECJ) JIT编译器:HotSpot VM的C1、 C2编译器 AOT编译器:GNU Compiler for the Java(GCJ)、 Excelsior JET javac这类编译器几乎不对代码进行性能优化,把性能优化放到了JIT即时编译器内,可为JRuby、 Groovy这类语言的代码也同等享有优化带来的好处 1-2. javac编译 1-2.1. 编译过程 解析与填充符号表过程 词法、语法分析 词法分析是将源代码的字符流转变为标记(Token)集合,单个字符是程序编写过程的最小元素,而标记则是编译过程的最小元素,关键字、 变量名、 字面量、 运算符都可以成为标记 语法分析是根据Token序列构造抽象语法树的过程,抽象语法树(Abstract Syntax Tree,AST)是一种用来描述程序代码语法结构的树形表示方式,语法树的每一个节点都代表着程序 代码中的一个语法结构(Construct),例如包、 类型、 修饰符、 运算符、 接口、 返回值甚至代码注释等都可以是一个语法结构. 填充符号表 符号表(Symbol Table)是由一组符号地址和符号信息构成的表格 在语义分析中,符号表所登记的内容将用于语义检查(如检查一个名字的使用和原先的说明是否一致)和产生中间代码.在目标代码生成阶段,当对符号名进行地址分配时,符号表是地址分配的依据. 插入式注解处理器的注解处理过程 分析与字节码生成过程 标注检查 检查的内容包括诸如变量使用前是否已被声明、 变量与赋值之间的数据类型是否能够匹配等 常量折叠 如定义了 int a = 1 + 2 会被编译为 int a = 3 数据及控制流分析 数据及控制流分析是对程序上下文逻辑更进一步的验证,它可以检查出诸如程序局部变量在使用前是否有赋值、 方法的每条路径是否都有返回值、 是否所有的受查异常都被正确处理了等问题. 语法糖 语法糖:也称糖衣语法,是由英国计算机科学家彼得·约翰·兰达(Peter J.Landin)发明的一个术语, 指在计算机语言中添加的某种语法,这种语法对语言的功能并没有影响,但是更方便程序员使用. 通常来说,使用语法糖能够增加程序的可读性,从而减少程序代码出错的机会. java语法糖:泛型、变长参数、 自动装箱/拆箱等 内部类、 枚举类、 断言语句、 对枚举和字符串(在JDK 1.7中支持) 的switch支持、 try语句中定义和关闭资源(在JDK 1.7中支持)等 泛型:编译器会进行解泛,所以泛型不能进行方法重载 自动装箱、 拆箱与遍历循环 条件编译 if 的条件为常量时编译期会被执行 字节码生成 字节码生成阶段不仅仅是把前面各个步骤所生成的信息(语法树、 符号表)转化成字节码写到磁盘中, 编译器还进行了少量的代码添加和转换工作. 2. 晚期(运行期)优化 2-1. 即时编译器(JIT) 为了提高热点代码的执行效率,在运行时,虚拟机将会把这些代码编译成与本地平台相关的机器码,并进行各种层次的优化, 完成这个任务的编译器称为即时编译器(Just In Time Compiler) 解释器与编译器(sun HotSpot虚拟机为例) 交互模型 +---------------即时编译-----------↓ ↓ Client Compiler(C1编译器) 解释器(Interpreter) 编译器 ↑ Server Compiler(C2编译器) +----------------逆优化------------↑ HotSpot虚拟机同时由解释器与编译器搭配使用(成为混合模式(Mixed Model)), 可添加参数-Xint强制虚拟机使用解释模式(Interpreted Mode),可添加参数-Xcomp强制虚拟机使用编译模式(Compiled Mode) 启动参数-client启用Client Compiler编译器 参数-server启用Server Compiler编译器 HotSpot虚拟机还会逐渐启用分层编译(Tiered Compilation)的策略,分层编译的概念在JDK 1.6时期出现, JDK1.7中Server模式中默认开启,之前需配参数-XX:+TieredCompilation启用 编译对象与触发条件 触发条件 被多次调用的方法 被多次执行的循环体,这个称为栈上替换(On Stack Replacement,简称为OSR编译) 热点代码判定 基于采样的热点探测,周期性检测个线程的栈顶,若某个方法经常在栈顶,则认为是热点方法； 优点是实现简单简单,高效,容易获取方法调用关系,缺点是不能准确判定一个方法的热度 基于计数器的热点探测,虚拟机为每个方法设定计数器,统计方法执行次数,若超过一定阈值则认为是热点方法； 优点是能准确判定一个方法的热度,缺点是要为每个方法建立计数器并维护,实现麻烦,也不能获取方法的调用关系 HotSpot虚拟机是基于计数器的热点探测,有2个计数器:方法调用计数器(Invocation Counter)和回边计数器(Back Edge Counter) 方法调用计数器,Client模式下阈值为1500次,Server模式下阈值为1000次,可由参数-XX:CompileThreshold来设置 -XX:-UseCounterDecay设置关闭热度衰减,-XX:CounterHalfLifeTime参数设置半衰周期的时间,单位是秒 回边计数器,参数-XX:OnStackReplacePercentage来间接调整回边计数器的阈值 Client模式下阈值计算公式: 方法调用计数器阈值(CompileThreshold)×OSR比率(OnStackReplacePercentage)[默认值为933]/100 默认情况下为13995 Server模式下阈值计算公式: 方法调用计数器阈值(CompileThreshold)×(OSR比率(OnStackReplacePercentage)[默认值140]-解释器监控比率(InterpreterProfilePercentage)[默认值33]/100 默认情况下为10700 编译过程 Client模式下编译过程 Server模式下编译过程 相当复杂 优化技术 公共子表达式消除 经典优化技术,如果一个表达式E已经计算过了,并且从先前的计算到现在E中所有变量的值都没有发生变化, 那么E的这次出现就成为了公共子表达式. 对于这种表达式,没有必要花时间再对它进行计算,只需要直接用前面计算过的表达式结果代替E就可以了 数组边界检查消除 语言相关的其他消除操作还有不少,如自动装箱消除(Autobox Elimination)、 安全点消除(Safepoint Elimination)、消除反射(Dereflection)等 方法内联 虚拟机最重要的优化手段之一,除了消除方法调用的成本之外,它更重要的意义是为其他优化手段建立良好的基础 非虚方法直接内联,虚方法引入了一种名为“类型继承关系分析”(Class Hierarchy Analysis,CHA)的技术, 检查发现没有多个目标版本可供选择,则也可内联,但需准备一个逃生门,即使有多个版本目标也会默认内联,但在调用时要检查, 发现版本目标不一致在取消内联,会从“逃生门”回到解释状态重新执行 逃逸分析(JDK1.6) 当下java最前沿的优化技术 逃逸分析的基本行为就是分析对象动态作用域:当一个对象在方法中被定义后,它可能被外部方法所引用, 例如作为调用参数传递到其他方法中,称为方法逃逸. 甚至还有可能被外部线程访问到, 譬如赋值给类变量或可以在其他线程中访问的实例变量,称为线程逃逸. 栈上分配(Stack Allocation),如果证明一个对象不会逃逸到方法之外,则可以将对象分配到方法栈帧内存,这样随着栈帧出栈而销毁,极大地降低了GC系统压力 同步消除(Synchronization Elimination),如果能证明一个变量不会逃逸出线程,那就可以消除掉同步措施,消除同步带来的消耗 标量替换(Scalar Replacement) 标量(Scalar),是指一个数据已经无法再分解成更小的数据来表示了,如:int,long,double等 聚合量(Aggregate),是指一个数据可以被分解,典型的java对象 如果证明一个对象不被外界访问,又可拆散的话,那程序在调用的时候就不创建该变量,改为创建多个成员变量来代替, 将对象拆分后,除了可以让对象的成员变量在栈上(栈上存储的数据,有很大的概率会被虚拟机分配至物理机器的高速寄存器中存储) 分配和读写之外,还可以为后续进一步的优化手段创建条件 逃逸分析尚不成熟" />
<meta property="og:description" content="1. 早期(编译期)优化 1-1. 概论 前端编译器:Sun的Javac、 Eclipse JDT中的增量式编译器(ECJ) JIT编译器:HotSpot VM的C1、 C2编译器 AOT编译器:GNU Compiler for the Java(GCJ)、 Excelsior JET javac这类编译器几乎不对代码进行性能优化,把性能优化放到了JIT即时编译器内,可为JRuby、 Groovy这类语言的代码也同等享有优化带来的好处 1-2. javac编译 1-2.1. 编译过程 解析与填充符号表过程 词法、语法分析 词法分析是将源代码的字符流转变为标记(Token)集合,单个字符是程序编写过程的最小元素,而标记则是编译过程的最小元素,关键字、 变量名、 字面量、 运算符都可以成为标记 语法分析是根据Token序列构造抽象语法树的过程,抽象语法树(Abstract Syntax Tree,AST)是一种用来描述程序代码语法结构的树形表示方式,语法树的每一个节点都代表着程序 代码中的一个语法结构(Construct),例如包、 类型、 修饰符、 运算符、 接口、 返回值甚至代码注释等都可以是一个语法结构. 填充符号表 符号表(Symbol Table)是由一组符号地址和符号信息构成的表格 在语义分析中,符号表所登记的内容将用于语义检查(如检查一个名字的使用和原先的说明是否一致)和产生中间代码.在目标代码生成阶段,当对符号名进行地址分配时,符号表是地址分配的依据. 插入式注解处理器的注解处理过程 分析与字节码生成过程 标注检查 检查的内容包括诸如变量使用前是否已被声明、 变量与赋值之间的数据类型是否能够匹配等 常量折叠 如定义了 int a = 1 + 2 会被编译为 int a = 3 数据及控制流分析 数据及控制流分析是对程序上下文逻辑更进一步的验证,它可以检查出诸如程序局部变量在使用前是否有赋值、 方法的每条路径是否都有返回值、 是否所有的受查异常都被正确处理了等问题. 语法糖 语法糖:也称糖衣语法,是由英国计算机科学家彼得·约翰·兰达(Peter J.Landin)发明的一个术语, 指在计算机语言中添加的某种语法,这种语法对语言的功能并没有影响,但是更方便程序员使用. 通常来说,使用语法糖能够增加程序的可读性,从而减少程序代码出错的机会. java语法糖:泛型、变长参数、 自动装箱/拆箱等 内部类、 枚举类、 断言语句、 对枚举和字符串(在JDK 1.7中支持) 的switch支持、 try语句中定义和关闭资源(在JDK 1.7中支持)等 泛型:编译器会进行解泛,所以泛型不能进行方法重载 自动装箱、 拆箱与遍历循环 条件编译 if 的条件为常量时编译期会被执行 字节码生成 字节码生成阶段不仅仅是把前面各个步骤所生成的信息(语法树、 符号表)转化成字节码写到磁盘中, 编译器还进行了少量的代码添加和转换工作. 2. 晚期(运行期)优化 2-1. 即时编译器(JIT) 为了提高热点代码的执行效率,在运行时,虚拟机将会把这些代码编译成与本地平台相关的机器码,并进行各种层次的优化, 完成这个任务的编译器称为即时编译器(Just In Time Compiler) 解释器与编译器(sun HotSpot虚拟机为例) 交互模型 +---------------即时编译-----------↓ ↓ Client Compiler(C1编译器) 解释器(Interpreter) 编译器 ↑ Server Compiler(C2编译器) +----------------逆优化------------↑ HotSpot虚拟机同时由解释器与编译器搭配使用(成为混合模式(Mixed Model)), 可添加参数-Xint强制虚拟机使用解释模式(Interpreted Mode),可添加参数-Xcomp强制虚拟机使用编译模式(Compiled Mode) 启动参数-client启用Client Compiler编译器 参数-server启用Server Compiler编译器 HotSpot虚拟机还会逐渐启用分层编译(Tiered Compilation)的策略,分层编译的概念在JDK 1.6时期出现, JDK1.7中Server模式中默认开启,之前需配参数-XX:+TieredCompilation启用 编译对象与触发条件 触发条件 被多次调用的方法 被多次执行的循环体,这个称为栈上替换(On Stack Replacement,简称为OSR编译) 热点代码判定 基于采样的热点探测,周期性检测个线程的栈顶,若某个方法经常在栈顶,则认为是热点方法； 优点是实现简单简单,高效,容易获取方法调用关系,缺点是不能准确判定一个方法的热度 基于计数器的热点探测,虚拟机为每个方法设定计数器,统计方法执行次数,若超过一定阈值则认为是热点方法； 优点是能准确判定一个方法的热度,缺点是要为每个方法建立计数器并维护,实现麻烦,也不能获取方法的调用关系 HotSpot虚拟机是基于计数器的热点探测,有2个计数器:方法调用计数器(Invocation Counter)和回边计数器(Back Edge Counter) 方法调用计数器,Client模式下阈值为1500次,Server模式下阈值为1000次,可由参数-XX:CompileThreshold来设置 -XX:-UseCounterDecay设置关闭热度衰减,-XX:CounterHalfLifeTime参数设置半衰周期的时间,单位是秒 回边计数器,参数-XX:OnStackReplacePercentage来间接调整回边计数器的阈值 Client模式下阈值计算公式: 方法调用计数器阈值(CompileThreshold)×OSR比率(OnStackReplacePercentage)[默认值为933]/100 默认情况下为13995 Server模式下阈值计算公式: 方法调用计数器阈值(CompileThreshold)×(OSR比率(OnStackReplacePercentage)[默认值140]-解释器监控比率(InterpreterProfilePercentage)[默认值33]/100 默认情况下为10700 编译过程 Client模式下编译过程 Server模式下编译过程 相当复杂 优化技术 公共子表达式消除 经典优化技术,如果一个表达式E已经计算过了,并且从先前的计算到现在E中所有变量的值都没有发生变化, 那么E的这次出现就成为了公共子表达式. 对于这种表达式,没有必要花时间再对它进行计算,只需要直接用前面计算过的表达式结果代替E就可以了 数组边界检查消除 语言相关的其他消除操作还有不少,如自动装箱消除(Autobox Elimination)、 安全点消除(Safepoint Elimination)、消除反射(Dereflection)等 方法内联 虚拟机最重要的优化手段之一,除了消除方法调用的成本之外,它更重要的意义是为其他优化手段建立良好的基础 非虚方法直接内联,虚方法引入了一种名为“类型继承关系分析”(Class Hierarchy Analysis,CHA)的技术, 检查发现没有多个目标版本可供选择,则也可内联,但需准备一个逃生门,即使有多个版本目标也会默认内联,但在调用时要检查, 发现版本目标不一致在取消内联,会从“逃生门”回到解释状态重新执行 逃逸分析(JDK1.6) 当下java最前沿的优化技术 逃逸分析的基本行为就是分析对象动态作用域:当一个对象在方法中被定义后,它可能被外部方法所引用, 例如作为调用参数传递到其他方法中,称为方法逃逸. 甚至还有可能被外部线程访问到, 譬如赋值给类变量或可以在其他线程中访问的实例变量,称为线程逃逸. 栈上分配(Stack Allocation),如果证明一个对象不会逃逸到方法之外,则可以将对象分配到方法栈帧内存,这样随着栈帧出栈而销毁,极大地降低了GC系统压力 同步消除(Synchronization Elimination),如果能证明一个变量不会逃逸出线程,那就可以消除掉同步措施,消除同步带来的消耗 标量替换(Scalar Replacement) 标量(Scalar),是指一个数据已经无法再分解成更小的数据来表示了,如:int,long,double等 聚合量(Aggregate),是指一个数据可以被分解,典型的java对象 如果证明一个对象不被外界访问,又可拆散的话,那程序在调用的时候就不创建该变量,改为创建多个成员变量来代替, 将对象拆分后,除了可以让对象的成员变量在栈上(栈上存储的数据,有很大的概率会被虚拟机分配至物理机器的高速寄存器中存储) 分配和读写之外,还可以为后续进一步的优化手段创建条件 逃逸分析尚不成熟" />
<link rel="canonical" href="https://dsolvers.github.io/content/java/2018/06/17/java-compile-and-optimize.html" />
<meta property="og:url" content="https://dsolvers.github.io/content/java/2018/06/17/java-compile-and-optimize.html" />
<meta property="og:site_name" content="Crab2Died" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-06-17T13:15:27+08:00" />
<script type="application/ld+json">
{"url":"https://dsolvers.github.io/content/java/2018/06/17/java-compile-and-optimize.html","headline":"Java Compile and Optimize","dateModified":"2018-06-17T13:15:27+08:00","datePublished":"2018-06-17T13:15:27+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://dsolvers.github.io/content/java/2018/06/17/java-compile-and-optimize.html"},"author":{"@type":"Person","name":"Crab2Died"},"description":"1. 早期(编译期)优化 1-1. 概论 前端编译器:Sun的Javac、 Eclipse JDT中的增量式编译器(ECJ) JIT编译器:HotSpot VM的C1、 C2编译器 AOT编译器:GNU Compiler for the Java(GCJ)、 Excelsior JET javac这类编译器几乎不对代码进行性能优化,把性能优化放到了JIT即时编译器内,可为JRuby、 Groovy这类语言的代码也同等享有优化带来的好处 1-2. javac编译 1-2.1. 编译过程 解析与填充符号表过程 词法、语法分析 词法分析是将源代码的字符流转变为标记(Token)集合,单个字符是程序编写过程的最小元素,而标记则是编译过程的最小元素,关键字、 变量名、 字面量、 运算符都可以成为标记 语法分析是根据Token序列构造抽象语法树的过程,抽象语法树(Abstract Syntax Tree,AST)是一种用来描述程序代码语法结构的树形表示方式,语法树的每一个节点都代表着程序 代码中的一个语法结构(Construct),例如包、 类型、 修饰符、 运算符、 接口、 返回值甚至代码注释等都可以是一个语法结构. 填充符号表 符号表(Symbol Table)是由一组符号地址和符号信息构成的表格 在语义分析中,符号表所登记的内容将用于语义检查(如检查一个名字的使用和原先的说明是否一致)和产生中间代码.在目标代码生成阶段,当对符号名进行地址分配时,符号表是地址分配的依据. 插入式注解处理器的注解处理过程 分析与字节码生成过程 标注检查 检查的内容包括诸如变量使用前是否已被声明、 变量与赋值之间的数据类型是否能够匹配等 常量折叠 如定义了 int a = 1 + 2 会被编译为 int a = 3 数据及控制流分析 数据及控制流分析是对程序上下文逻辑更进一步的验证,它可以检查出诸如程序局部变量在使用前是否有赋值、 方法的每条路径是否都有返回值、 是否所有的受查异常都被正确处理了等问题. 语法糖 语法糖:也称糖衣语法,是由英国计算机科学家彼得·约翰·兰达(Peter J.Landin)发明的一个术语, 指在计算机语言中添加的某种语法,这种语法对语言的功能并没有影响,但是更方便程序员使用. 通常来说,使用语法糖能够增加程序的可读性,从而减少程序代码出错的机会. java语法糖:泛型、变长参数、 自动装箱/拆箱等 内部类、 枚举类、 断言语句、 对枚举和字符串(在JDK 1.7中支持) 的switch支持、 try语句中定义和关闭资源(在JDK 1.7中支持)等 泛型:编译器会进行解泛,所以泛型不能进行方法重载 自动装箱、 拆箱与遍历循环 条件编译 if 的条件为常量时编译期会被执行 字节码生成 字节码生成阶段不仅仅是把前面各个步骤所生成的信息(语法树、 符号表)转化成字节码写到磁盘中, 编译器还进行了少量的代码添加和转换工作. 2. 晚期(运行期)优化 2-1. 即时编译器(JIT) 为了提高热点代码的执行效率,在运行时,虚拟机将会把这些代码编译成与本地平台相关的机器码,并进行各种层次的优化, 完成这个任务的编译器称为即时编译器(Just In Time Compiler) 解释器与编译器(sun HotSpot虚拟机为例) 交互模型 +---------------即时编译-----------↓ ↓ Client Compiler(C1编译器) 解释器(Interpreter) 编译器 ↑ Server Compiler(C2编译器) +----------------逆优化------------↑ HotSpot虚拟机同时由解释器与编译器搭配使用(成为混合模式(Mixed Model)), 可添加参数-Xint强制虚拟机使用解释模式(Interpreted Mode),可添加参数-Xcomp强制虚拟机使用编译模式(Compiled Mode) 启动参数-client启用Client Compiler编译器 参数-server启用Server Compiler编译器 HotSpot虚拟机还会逐渐启用分层编译(Tiered Compilation)的策略,分层编译的概念在JDK 1.6时期出现, JDK1.7中Server模式中默认开启,之前需配参数-XX:+TieredCompilation启用 编译对象与触发条件 触发条件 被多次调用的方法 被多次执行的循环体,这个称为栈上替换(On Stack Replacement,简称为OSR编译) 热点代码判定 基于采样的热点探测,周期性检测个线程的栈顶,若某个方法经常在栈顶,则认为是热点方法； 优点是实现简单简单,高效,容易获取方法调用关系,缺点是不能准确判定一个方法的热度 基于计数器的热点探测,虚拟机为每个方法设定计数器,统计方法执行次数,若超过一定阈值则认为是热点方法； 优点是能准确判定一个方法的热度,缺点是要为每个方法建立计数器并维护,实现麻烦,也不能获取方法的调用关系 HotSpot虚拟机是基于计数器的热点探测,有2个计数器:方法调用计数器(Invocation Counter)和回边计数器(Back Edge Counter) 方法调用计数器,Client模式下阈值为1500次,Server模式下阈值为1000次,可由参数-XX:CompileThreshold来设置 -XX:-UseCounterDecay设置关闭热度衰减,-XX:CounterHalfLifeTime参数设置半衰周期的时间,单位是秒 回边计数器,参数-XX:OnStackReplacePercentage来间接调整回边计数器的阈值 Client模式下阈值计算公式: 方法调用计数器阈值(CompileThreshold)×OSR比率(OnStackReplacePercentage)[默认值为933]/100 默认情况下为13995 Server模式下阈值计算公式: 方法调用计数器阈值(CompileThreshold)×(OSR比率(OnStackReplacePercentage)[默认值140]-解释器监控比率(InterpreterProfilePercentage)[默认值33]/100 默认情况下为10700 编译过程 Client模式下编译过程 Server模式下编译过程 相当复杂 优化技术 公共子表达式消除 经典优化技术,如果一个表达式E已经计算过了,并且从先前的计算到现在E中所有变量的值都没有发生变化, 那么E的这次出现就成为了公共子表达式. 对于这种表达式,没有必要花时间再对它进行计算,只需要直接用前面计算过的表达式结果代替E就可以了 数组边界检查消除 语言相关的其他消除操作还有不少,如自动装箱消除(Autobox Elimination)、 安全点消除(Safepoint Elimination)、消除反射(Dereflection)等 方法内联 虚拟机最重要的优化手段之一,除了消除方法调用的成本之外,它更重要的意义是为其他优化手段建立良好的基础 非虚方法直接内联,虚方法引入了一种名为“类型继承关系分析”(Class Hierarchy Analysis,CHA)的技术, 检查发现没有多个目标版本可供选择,则也可内联,但需准备一个逃生门,即使有多个版本目标也会默认内联,但在调用时要检查, 发现版本目标不一致在取消内联,会从“逃生门”回到解释状态重新执行 逃逸分析(JDK1.6) 当下java最前沿的优化技术 逃逸分析的基本行为就是分析对象动态作用域:当一个对象在方法中被定义后,它可能被外部方法所引用, 例如作为调用参数传递到其他方法中,称为方法逃逸. 甚至还有可能被外部线程访问到, 譬如赋值给类变量或可以在其他线程中访问的实例变量,称为线程逃逸. 栈上分配(Stack Allocation),如果证明一个对象不会逃逸到方法之外,则可以将对象分配到方法栈帧内存,这样随着栈帧出栈而销毁,极大地降低了GC系统压力 同步消除(Synchronization Elimination),如果能证明一个变量不会逃逸出线程,那就可以消除掉同步措施,消除同步带来的消耗 标量替换(Scalar Replacement) 标量(Scalar),是指一个数据已经无法再分解成更小的数据来表示了,如:int,long,double等 聚合量(Aggregate),是指一个数据可以被分解,典型的java对象 如果证明一个对象不被外界访问,又可拆散的话,那程序在调用的时候就不创建该变量,改为创建多个成员变量来代替, 将对象拆分后,除了可以让对象的成员变量在栈上(栈上存储的数据,有很大的概率会被虚拟机分配至物理机器的高速寄存器中存储) 分配和读写之外,还可以为后续进一步的优化手段创建条件 逃逸分析尚不成熟","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://dsolvers.github.io/feed.xml" title="Crab2Died" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Crab2Died</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about.html">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name p-title" itemprop="name headline">Java Compile and Optimize</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-06-17T13:15:27+08:00" itemprop="datePublished">Jun 17, 2018
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Crab2Died</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="1-早期编译期优化">1. 早期(编译期)优化</h2>
<h3 id="1-1-概论">1-1. 概论</h3>
<ol>
  <li>前端编译器:Sun的Javac、 Eclipse JDT中的增量式编译器(ECJ)
    <ul>
      <li>JIT编译器:HotSpot VM的C1、 C2编译器</li>
      <li>AOT编译器:GNU Compiler for the Java(GCJ)、 Excelsior JET</li>
    </ul>
  </li>
  <li>javac这类编译器几乎不对代码进行性能优化,把性能优化放到了JIT即时编译器内,可为JRuby、
Groovy这类语言的代码也同等享有优化带来的好处</li>
</ol>

<h3 id="1-2-javac编译">1-2. javac编译</h3>
<h4 id="1-21-编译过程">1-2.1. 编译过程</h4>
<ol>
  <li>解析与填充符号表过程
    <ul>
      <li>词法、语法分析
        <ul>
          <li>词法分析是将源代码的字符流转变为标记(Token)集合,单个字符是程序编写过程的最小元素,而标记则是编译过程的最小元素,关键字、 变量名、 字面量、 运算符都可以成为标记</li>
          <li>语法分析是根据Token序列构造抽象语法树的过程,抽象语法树(Abstract Syntax Tree,AST)是一种用来描述程序代码语法结构的树形表示方式,语法树的每一个节点都代表着程序
代码中的一个语法结构(Construct),例如包、 类型、 修饰符、 运算符、 接口、 返回值甚至代码注释等都可以是一个语法结构.</li>
        </ul>
      </li>
      <li>填充符号表
        <ul>
          <li>符号表(Symbol Table)是由一组符号地址和符号信息构成的表格</li>
          <li>在语义分析中,符号表所登记的内容将用于语义检查(如检查一个名字的使用和原先的说明是否一致)和产生中间代码.在目标代码生成阶段,当对符号名进行地址分配时,符号表是地址分配的依据.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>插入式注解处理器的注解处理过程</li>
  <li>分析与字节码生成过程
    <ul>
      <li>标注检查
        <ul>
          <li>检查的内容包括诸如变量使用前是否已被声明、 变量与赋值之间的数据类型是否能够匹配等</li>
          <li>常量折叠 如定义了<code class="highlighter-rouge"> int a = 1 + 2 </code>会被编译为<code class="highlighter-rouge"> int a = 3 </code></li>
        </ul>
      </li>
      <li>数据及控制流分析
        <ul>
          <li>数据及控制流分析是对程序上下文逻辑更进一步的验证,它可以检查出诸如程序局部变量在使用前是否有赋值、
 方法的每条路径是否都有返回值、 是否所有的受查异常都被正确处理了等问题.</li>
        </ul>
      </li>
      <li>语法糖
        <ul>
          <li>语法糖:也称糖衣语法,是由英国计算机科学家彼得·约翰·兰达(Peter J.Landin)发明的一个术语,
 指在计算机语言中添加的某种语法,这种语法对语言的功能并没有影响,但是更方便程序员使用.
 通常来说,使用语法糖能够增加程序的可读性,从而减少程序代码出错的机会.</li>
          <li>java语法糖:泛型、变长参数、 自动装箱/拆箱等 内部类、 枚举类、 断言语句、 对枚举和字符串(在JDK 1.7中支持)
 的switch支持、 try语句中定义和关闭资源(在JDK 1.7中支持)等</li>
          <li>泛型:编译器会进行解泛,所以泛型不能进行方法重载</li>
          <li>自动装箱、 拆箱与遍历循环</li>
          <li>条件编译 if 的条件为常量时编译期会被执行</li>
        </ul>
      </li>
      <li>字节码生成
        <ul>
          <li>字节码生成阶段不仅仅是把前面各个步骤所生成的信息(语法树、 符号表)转化成字节码写到磁盘中,
 编译器还进行了少量的代码添加和转换工作.</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h2 id="2-晚期运行期优化">2. 晚期(运行期)优化</h2>
<h3 id="2-1-即时编译器jit">2-1. 即时编译器(JIT)</h3>
<ol>
  <li>为了提高热点代码的执行效率,在运行时,虚拟机将会把这些代码编译成与本地平台相关的机器码,并进行各种层次的优化,
完成这个任务的编译器称为即时编译器(Just In Time Compiler)</li>
  <li>解释器与编译器(sun HotSpot虚拟机为例)
    <ul>
      <li>交互模型
        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     +---------------即时编译-----------↓
     ↓                         Client Compiler(C1编译器)
  解释器(Interpreter)               编译器
     ↑                         Server Compiler(C2编译器)
     +----------------逆优化------------↑
</code></pre></div>        </div>
      </li>
      <li>HotSpot虚拟机同时由解释器与编译器搭配使用(成为混合模式(Mixed Model)),
可添加参数-Xint强制虚拟机使用解释模式(Interpreted Mode),可添加参数<code class="highlighter-rouge">-Xcomp</code>强制虚拟机使用编译模式(Compiled Mode)</li>
      <li>启动参数<code class="highlighter-rouge">-client</code>启用Client Compiler编译器 参数<code class="highlighter-rouge">-server</code>启用Server Compiler编译器</li>
      <li>HotSpot虚拟机还会逐渐启用分层编译(Tiered Compilation)的策略,分层编译的概念在JDK 1.6时期出现,
JDK1.7中Server模式中默认开启,之前需配参数<code class="highlighter-rouge">-XX:+TieredCompilation</code>启用</li>
    </ul>
  </li>
  <li>编译对象与触发条件
    <ul>
      <li>触发条件
        <ul>
          <li>被多次调用的方法</li>
          <li>被多次执行的循环体,这个称为栈上替换(On Stack Replacement,简称为OSR编译)</li>
        </ul>
      </li>
      <li>热点代码判定
        <ul>
          <li>基于采样的热点探测,周期性检测个线程的栈顶,若某个方法经常在栈顶,则认为是热点方法；
 优点是实现简单简单,高效,容易获取方法调用关系,缺点是不能准确判定一个方法的热度</li>
          <li>基于计数器的热点探测,虚拟机为每个方法设定计数器,统计方法执行次数,若超过一定阈值则认为是热点方法；
 优点是能准确判定一个方法的热度,缺点是要为每个方法建立计数器并维护,实现麻烦,也不能获取方法的调用关系</li>
        </ul>
      </li>
      <li>HotSpot虚拟机是基于计数器的热点探测,有2个计数器:方法调用计数器(Invocation Counter)和回边计数器(Back Edge Counter)
        <ul>
          <li>方法调用计数器,Client模式下阈值为1500次,Server模式下阈值为1000次,可由参数<code class="highlighter-rouge">-XX:CompileThreshold</code>来设置
 <code class="highlighter-rouge">-XX:-UseCounterDecay</code>设置关闭热度衰减,<code class="highlighter-rouge">-XX:CounterHalfLifeTime</code>参数设置半衰周期的时间,单位是秒</li>
          <li>回边计数器,参数<code class="highlighter-rouge">-XX:OnStackReplacePercentage</code>来间接调整回边计数器的阈值<br />
 Client模式下阈值计算公式:<br />
 <code class="highlighter-rouge">方法调用计数器阈值(CompileThreshold)×OSR比率(OnStackReplacePercentage)[默认值为933]/100</code> 默认情况下为13995<br />
 Server模式下阈值计算公式:<br />
 <code class="highlighter-rouge">方法调用计数器阈值(CompileThreshold)×(OSR比率(OnStackReplacePercentage)[默认值140]-解释器监控比率(InterpreterProfilePercentage)[默认值33]/100</code>
 默认情况下为10700</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>编译过程
    <ul>
      <li>Client模式下编译过程<br />
 <img src="https://raw.githubusercontent.com/Crab2died/jdepth/master/src/main/java/com/github/jvm/optimize/Client-Compiler%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" alt="Client Compiler编译过程" /></li>
      <li>Server模式下编译过程<br />
 相当复杂</li>
    </ul>
  </li>
  <li>优化技术
    <ul>
      <li>公共子表达式消除
        <ul>
          <li>经典优化技术,如果一个表达式E已经计算过了,并且从先前的计算到现在E中所有变量的值都没有发生变化,
 那么E的这次出现就成为了公共子表达式. 对于这种表达式,没有必要花时间再对它进行计算,只需要直接用前面计算过的表达式结果代替E就可以了</li>
        </ul>
      </li>
      <li>数组边界检查消除
        <ul>
          <li>语言相关的其他消除操作还有不少,如自动装箱消除(Autobox Elimination)、 安全点消除(Safepoint Elimination)、消除反射(Dereflection)等</li>
        </ul>
      </li>
      <li>方法内联
        <ul>
          <li>虚拟机最重要的优化手段之一,除了消除方法调用的成本之外,它更重要的意义是为其他优化手段建立良好的基础</li>
          <li>非虚方法直接内联,虚方法引入了一种名为“类型继承关系分析”(Class Hierarchy Analysis,CHA)的技术,
 检查发现没有多个目标版本可供选择,则也可内联,但需准备一个逃生门,即使有多个版本目标也会默认内联,但在调用时要检查,
 发现版本目标不一致在取消内联,会从“逃生门”回到解释状态重新执行</li>
        </ul>
      </li>
      <li>逃逸分析(JDK1.6)
        <ul>
          <li>当下java最前沿的优化技术</li>
          <li>逃逸分析的基本行为就是分析对象动态作用域:当一个对象在方法中被定义后,它可能被外部方法所引用,
 例如作为调用参数传递到其他方法中,称为方法逃逸. 甚至还有可能被外部线程访问到,
 譬如赋值给类变量或可以在其他线程中访问的实例变量,称为线程逃逸.</li>
          <li>栈上分配(Stack Allocation),如果证明一个对象不会逃逸到方法之外,则可以将对象分配到方法栈帧内存,这样随着栈帧出栈而销毁,极大地降低了GC系统压力</li>
          <li>同步消除(Synchronization Elimination),如果能证明一个变量不会逃逸出线程,那就可以消除掉同步措施,消除同步带来的消耗</li>
          <li>标量替换(Scalar Replacement)
 标量(Scalar),是指一个数据已经无法再分解成更小的数据来表示了,如:<code class="highlighter-rouge">int</code>,<code class="highlighter-rouge">long</code>,<code class="highlighter-rouge">double</code>等
 聚合量(Aggregate),是指一个数据可以被分解,典型的java对象
 如果证明一个对象不被外界访问,又可拆散的话,那程序在调用的时候就不创建该变量,改为创建多个成员变量来代替,
 将对象拆分后,除了可以让对象的成员变量在栈上(栈上存储的数据,有很大的概率会被虚拟机分配至物理机器的高速寄存器中存储)
 分配和读写之外,还可以为后续进一步的优化手段创建条件</li>
          <li>逃逸分析尚不成熟</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

  </div><a class="u-url" href="/content/java/2018/06/17/java-compile-and-optimize.html" hidden></a>

</article>

<div style="position: relative; height: 25px; margin-bottom: 5px;"><div class="post-previous"><a href="/content/database/2018/06/18/database.html"><strong>←</strong> Prev Article</a></div><div class="post-next"><a href="/content/java/2018/06/15/java-gc.html">Next Article <strong>→</strong></a></div></div>
<!--<div id="disqus_thread"></div>-->
<!--<script>-->

<!--/**-->
<!--*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.-->
<!--*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/-->
<!--/*-->
<!--var disqus_config = function () {-->
<!--this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable-->
<!--this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable-->
<!--};-->
<!--*/-->
<!--(function() { // DON'T EDIT BELOW THIS LINE-->
<!--var d = document, s = d.createElement('script');-->
<!--s.src = 'https://crab2died.disqus.com/embed.js';-->
<!--s.setAttribute('data-timestamp', +new Date());-->
<!--(d.head || d.body).appendChild(s);-->
<!--})();-->
<!--</script>-->
<!--<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>-->
<div class="line-post"></div>

<div id="container"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    var gitment = new Gitment({
        id: '2018061700001', // 可选。默认为 location.href
        owner: 'Crab2Died',
        repo: 'crab2died.github.io',
        oauth: {
            client_id: '42913a1fc0807a42aa5c',
            client_secret: 'db91f2a8a0aef69badfd34ce02b0c7f5148b7592'
        }
    });
    gitment.render('container')
</script>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Crab2Died</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Copyright ©2018 Crab2Died</li><li><a class="u-email" href="mailto:Crab2Died@126.com">Crab2Died@126.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Crab2Died"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Crab2Died</span></a></li><li><a href="/feed.xml"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg> <span>via RSS</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>D(data/digit) Solvers</p>
      </div>
    </div>

  </div>
<script>
    // baidu tongji
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?669141ef93f4209be04bb674c56cba17";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>
</footer>
</body>
<!--<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<!--<script type="text/x-mathjax-config">-->
  <!--MathJax.Hub.Config({-->
    <!--tex2jax: {-->
      <!--skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],-->
      <!--inlineMath: [['$','$']]-->
    <!--}-->
  <!--});-->
<!--</script>-->
</html>
