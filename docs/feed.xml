<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="https://crab2died.github.io/jekyll-blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://crab2died.github.io/jekyll-blog/" rel="alternate" type="text/html" /><updated>2018-06-19T11:32:12+08:00</updated><id>https://crab2died.github.io/jekyll-blog/</id><title type="html">Crab2Died Blog</title><subtitle>Crab2Died's personal blog website.</subtitle><author><name>Copyright ©2018 Crab2Died</name></author><entry><title type="html">The Interview Experience</title><link href="https://crab2died.github.io/jekyll-blog/content/interview/2018/06/19/interview-experience.html" rel="alternate" type="text/html" title="The Interview Experience" /><published>2018-06-19T09:15:27+08:00</published><updated>2018-06-19T09:15:27+08:00</updated><id>https://crab2died.github.io/jekyll-blog/content/interview/2018/06/19/interview-experience</id><content type="html" xml:base="https://crab2died.github.io/jekyll-blog/content/interview/2018/06/19/interview-experience.html">&lt;h2 id=&quot;一-java基础&quot;&gt;一. JAVA基础&lt;/h2&gt;
&lt;h3 id=&quot;1-9种基本数据类型及其封装类所占大小&quot;&gt;1. 9种基本数据类型及其封装类,所占大小&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;类型&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;包装类&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;大小(字节)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;byte&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Byte&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;char&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Character&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;short&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Short&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Integer&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Float&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;double&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Double&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;long&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Long&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;void&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Void&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;2-object类方法&quot;&gt;2. Object类方法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;getClass() 获取类对象Class (native)&lt;/li&gt;
  &lt;li&gt;hashCode() 获取hashCode值(native)&lt;/li&gt;
  &lt;li&gt;equals(Object) 判断是否同一对象&lt;/li&gt;
  &lt;li&gt;clone() 对象克隆(native)&lt;/li&gt;
  &lt;li&gt;wait()&lt;/li&gt;
  &lt;li&gt;wait(timeout)&lt;/li&gt;
  &lt;li&gt;wait(timeout, nanos)&lt;/li&gt;
  &lt;li&gt;notify()&lt;/li&gt;
  &lt;li&gt;notifyAll()&lt;/li&gt;
  &lt;li&gt;toString()&lt;/li&gt;
  &lt;li&gt;finalize() (protected)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-equals-hashcode-比较&quot;&gt;3. equals 、hashCode、== 比较&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;equals是Object类方法，内部实现的是判断对象是否相等(即 ==)。&lt;/li&gt;
  &lt;li&gt;hashCode是Object的native方法，返回的是类似表示对象地址的整数。&lt;/li&gt;
  &lt;li&gt;==是判断2个对象是否相同。&lt;/li&gt;
  &lt;li&gt;如果2个对象相同则hashCode一定相等，若2个对象不同hashCode不一定相等。&lt;/li&gt;
  &lt;li&gt;一般地重写了equals方法建议也要重写hashCode方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-面向对象的特性与含义&quot;&gt;4. 面向对象的特性与含义&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;抽象&lt;/strong&gt;  是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不
关注这些行为的细节是什么。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;封装&lt;/strong&gt;  是指将某事物的属性和行为包装到对象中，这个对象只对外公布需要公开的属性和行为，而这个公布也是可以有选择性的公布
给其它对象，private、protected、public三种修饰符或不用(即默认default)对外部对象访问该对象的属性和行为进行限制。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;继承&lt;/strong&gt;  是子对象可以继承父对象的属性和行为，亦即父对象拥有的属性和行为，其子对象也就拥有了这些属性和行为。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;多态&lt;/strong&gt;  是指父对象中的同一个行为能在其多个子对象中有不同的表现。也就是说子对象可以使用重写父对象中的行为,使其拥有不同于
     父对象和其它子对象的表现,这就是overriding(重写)。实现多态的技术称为：动态绑定(dynamic binding)，是指在执行期间判
断所引用对象的实际类型，根据其实际的类型调用其相应的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-override与overload&quot;&gt;5. Override与Overload&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Override&lt;/strong&gt;是重写:方法名称、参数个数，类型，顺序，返回值类型都是必须和父类方法一致的。它的关系是父子关系。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Overload&lt;/strong&gt;是重载:方法名称不变，方法参数个数、类型、顺序至少一个不同。它的关系是同一个类，同一个方法名。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6-wait与sleep&quot;&gt;6. wait与sleep&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;wait是Object类的方法；而sleep是Thread类的静态方法。&lt;/li&gt;
  &lt;li&gt;当线程执行到wait方法时，他就会进入到该对象相关的等待池中，同时释放对象的机锁，其他线程可访问，直到超时或该对象调用notify
或notifyAll；而当线程执行sleep方法时，线程进入阻塞状态，让出CPU资源，但在Synchronized同步块中不能释放对象的锁。&lt;/li&gt;
  &lt;li&gt;wait方法必须放在synchronized代码块中，否则会在时抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.IllegalMonitorStateException&lt;/code&gt;异常。&lt;/li&gt;
  &lt;li&gt;wait和sleep都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException(但不建议使用该方法)。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;7-java并发&quot;&gt;7. java并发&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/jekyll-blog/content/java/2018/06/15/java-concurrent.html&quot;&gt;java并发编程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8-interface与abstract类&quot;&gt;8. interface与abstract类&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;抽象类是包含有抽象方法的类(也可以拥有成员变量和普通成员方法)，抽象方法是只有方法声明没有具体实现的方法，所以抽象类不能实例化，是为
了继承而存的，抽象类与普通类有3点区别：
    &lt;ul&gt;
      &lt;li&gt;1.抽象方法必须是public或protected，缺损情况下默认为public;&lt;/li&gt;
      &lt;li&gt;2.抽象类不能被实例化；&lt;/li&gt;
      &lt;li&gt;3.如果一个类继承了抽象类，则子类必须实现父类的抽象方法，若没有实现父类抽象方法，则子类也必须定义为抽象类。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;接口是泛指供别人调用的方法或函数，接口中可以有变量和方法，变量被隐式地指定为&lt;code class=&quot;highlighter-rouge&quot;&gt;public static final&lt;/code&gt;，方法被隐式地指定为
&lt;code class=&quot;highlighter-rouge&quot;&gt;public abstract&lt;/code&gt;,接口中的方法不能有具体的实现(JDK8之后接口可以有default方法)。&lt;/li&gt;
  &lt;li&gt;接口与抽象类比较:
    &lt;ul&gt;
      &lt;li&gt;1.语法层面上:
        &lt;ul&gt;
          &lt;li&gt;1).抽象类可以提供成员方法的实现细节而接口中只能存在public abstract方法&lt;/li&gt;
          &lt;li&gt;2).抽象类中的成员变量可以是各种类型，而接口中的成员变量只能是public static final类型&lt;/li&gt;
          &lt;li&gt;3).接口中不能存在静态代码块和静态方法，而抽象类中可以&lt;/li&gt;
          &lt;li&gt;4).一个类只能继承一个抽象类而可以实现多个接口&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2.设计层面上:
        &lt;ul&gt;
          &lt;li&gt;1).抽象类是对一种事物对象的抽象，而接口是对事物行为的抽象，抽象类是对整个类整体的抽象，包括属性、行为，而接口是对类的局部
(行为)的抽象。继承抽象类是”是不是”的关系，实现接口是”有没有”的关系。&lt;/li&gt;
          &lt;li&gt;2).设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计，而接口是一种行为规范，它是一种辐射式设计&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;9-fail-fast&quot;&gt;9. fail-fast&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;fail-fast：机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。
例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出异常: 
&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentModificationException&lt;/code&gt;，产生fail-fast事件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;10-jdk和cglib动态代理&quot;&gt;10. JDK和CGLIB动态代理&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JDK动态代理只能针对实现了接口的类生成代理(实例化一个类)。此时代理对象和目标对象实现了相同的接口，目标对象作为代理对象的一个属性，
具体接口实现中，可以在调用目标对象相应方法前后加上其他业务处理逻辑。&lt;/li&gt;
  &lt;li&gt;CGLIB是针对类实现代理，主要是对指定的类生成一个子类(没有实例化一个类)，覆盖其中的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jvm&quot;&gt;JVM&lt;/h2&gt;
&lt;h3 id=&quot;1-内存模型&quot;&gt;1. 内存模型&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;堆内存(Heap)&lt;/strong&gt; 是线程间共享内存，主要存放java的对象及数组&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;栈内存(Stack)&lt;/strong&gt; 是线程间不共享的，主要存放基本数据类型和对象及数组的引用等&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;方法区(Method Area)&lt;/strong&gt; 是存储已被虚拟机加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;本地方法栈(Native Method Stack)&lt;/strong&gt; 为虚拟机调用本地Native方法提供服务,有的虚拟机与虚拟机栈合二为一&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;程序计数器(Program Counter Register)&lt;/strong&gt; 是当前虚拟机执行指令的地址，当执行到Native方法时其值为空(Undefined)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;运行时常量池(Runtime Constant Pool)&lt;/strong&gt; 用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;直接内存(Direct Memory)&lt;/strong&gt; NIO的DirectByteBuffer对象使用直接内存,这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-gc的2种判定方法&quot;&gt;2. GC的2种判定方法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;引用计数&lt;/strong&gt;: 实现简单、高效，但会出现循环引用的时候对象将无法得到回收&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;引用链&lt;/strong&gt;：即可达性分析，以GC Roots为根节点开始向下搜索，所走的路径叫做引用链(Reference Chain)，当一个对象到GC Roots对象没有
任何引用链时说明该对象不可用，可作为GC Roots的对象：
    &lt;ul&gt;
      &lt;li&gt;1.虚拟机栈（栈帧中的本地变量表）中引用的对象。&lt;/li&gt;
      &lt;li&gt;2.方法区中的类静态属性引用的对象或者常量引用的对象。&lt;/li&gt;
      &lt;li&gt;3.本地方法栈中JNI（就是native方法）引用的对象。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-java自动内存管理&quot;&gt;3. java自动内存管理&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/jekyll-blog/content/java/2018/06/15/java-gc.html&quot;&gt;java自动内存管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;h3 id=&quot;1-osi网络模型&quot;&gt;1. OSI网络模型&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;层级&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;名称&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;应用层&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;指网络操作系统和具体的应用程序，对应WWW服务器、FTP服务器等应用软件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;表示层&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据语法的转换、数据的传送等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;会话层&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;建立起两端之间的会话关系，并负责数据的传送&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;传输层&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;负责错误的检查与修复，以确保传送的质量，是TCP/UDP工作的地方。（报文）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;网络层&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;提供了编址方案,IP协议工作的地方(数据包）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;数据链路层&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;将由物理层传来的未经处理的位数据包装成数据帧&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;物理层&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;对应网线、网卡、接口等物理设备(位)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;2-tcpip协议&quot;&gt;2. TCP/IP协议&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;应用层&lt;/li&gt;
  &lt;li&gt;传输层&lt;/li&gt;
  &lt;li&gt;网络层&lt;/li&gt;
  &lt;li&gt;链路层&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-ip分类&quot;&gt;3. IP分类&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;A类地址（1.0.0.0-126.255.255.255）用于最大型的网络，该网络的节点数可达16,777,216个。&lt;/li&gt;
  &lt;li&gt;B类地址（128.0.0.0-191.255.255.255）用于中型网络，节点数可达65,536个。&lt;/li&gt;
  &lt;li&gt;C类地址（192.0.0.0-223.255.255.255）用于256个节点以下的小型网络的单点网络通信。&lt;/li&gt;
  &lt;li&gt;D类地址（224.0.0.0-239.255.255.255）并不反映网络的大小，只是用于组播，用来指定所分配的接收组播的节点组，这个节点组由组播订
阅成员组成。D类地址的范围为&lt;/li&gt;
  &lt;li&gt;E类（240.0.0.0-255.255.255.254）地址用于试验。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-tcp与udp&quot;&gt;4. TCP与UDP&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;TCP、UDP都是传输层协议&lt;/li&gt;
  &lt;li&gt;TCP(Transmission Control Protocol, 传输控制协议) 是面向连接的协议(即在收发数据前必须和对方建立可靠连接)，TCP建立连接要3次
握手，TCP断开连接需要4次挥手，保证了数据通信的可靠性；TCP包头最小长度为20个字节数。&lt;/li&gt;
  &lt;li&gt;UDP(User Data Protocol, 用户数据报协议) 是一个非连接的协议(即传输数据之前源端和终端不建立连接)，只是简单的把应用程序的数据
尽快地扔到网络上，因此UDP传输速度只受应用程序生成数据速度、计算机的能力和传输带宽的限制，接收端，UDP把每个消息段放入队列中
应用程序读取使用；UDP可以一台服务器同时向多台客户机传输相同数据；UDP消息头很短只有8个字节；UDP尽可能快的发送数据，但不保证
数据的可靠性(丢包，顺序等)；UDP是面向报文的，发送方的报文只是添加首部后就向下交付给IP层，既不拆分也不合并，这些需要接收端
应用程序自己实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-死锁的必要条件&quot;&gt;5. 死锁的必要条件&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;互斥条件&lt;/strong&gt;：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源
被另一进程占有时，则申请者等待直到资源被占有者释放。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;不可剥夺条件&lt;/strong&gt;：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;请求和保持条件&lt;/strong&gt;：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;循环等待条件&lt;/strong&gt;：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有
的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6-mysql索引55之前默认myisam引擎55之后默认innodb&quot;&gt;6. MySQL索引(5.5之前默认MyISAM引擎，5.5之后默认InnoDB)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;MyISAM使用B-Tree实现主键索引、唯一索引和非主键索引。&lt;/li&gt;
  &lt;li&gt;InnoDB中非主键索引使用的是B-Tree数据结构，而主键索引使用的是B+Tree。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;7-进程与线程&quot;&gt;7. 进程与线程&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元&lt;/li&gt;
  &lt;li&gt;同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。&lt;/li&gt;
  &lt;li&gt;进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进
程中的其他线程的结束&lt;/li&gt;
  &lt;li&gt;线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的&lt;/li&gt;
  &lt;li&gt;线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源&lt;/li&gt;
  &lt;li&gt;线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标
示一个进程或一个线程的标志&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8-ipc通信方式&quot;&gt;8. IPC通信方式&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;管道(Pipe)&lt;/strong&gt;：匿名管道（pipe亲缘关系的进程通信）、命名管道（mkfifo/mknod）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;消息队列&lt;/strong&gt;：是基于消息的、用无亲缘关系的进程间通信，主要函数：msgget、msgsend、msgrecv、msgctl&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;信号量&lt;/strong&gt;：相当于一把互斥锁，通过p、v操作，主要函数：semget、semop、semctl&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;共享内存&lt;/strong&gt;：是进程间通信速度最快的，所以用经常是集合信号量或互斥锁来实现同步，shmget、shmat、shmdt、shmctl&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;9-虚拟内存&quot;&gt;9. 虚拟内存&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;是将进程部分装入内存中，从而能实现一个很大的程序能在一个比它小的内存中运行，它的主要实现是靠程序的换进换出来实现的，因为内存
中0-3G是用户使用，3-4G才是内存使用，通过映射来实现来进行逻辑地址到物理地址的映射&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;10-设计原则&quot;&gt;10. 设计原则&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;依赖倒置原则－Dependency Inversion Principle (DIP)&lt;/li&gt;
  &lt;li&gt;里氏替换原则－Liskov Substitution Principle (LSP)&lt;/li&gt;
  &lt;li&gt;接口分隔原则－Interface Segregation Principle (ISP)&lt;/li&gt;
  &lt;li&gt;单一职责原则－Single Responsibility Principle (SRP)&lt;/li&gt;
  &lt;li&gt;开闭原则－The Open-Closed Principle (OCP)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Crab2Died</name></author><category term="Java" /><category term="Interview" /><category term="Experience" /><summary type="html">一. JAVA基础 1. 9种基本数据类型及其封装类,所占大小</summary></entry><entry><title type="html">Database</title><link href="https://crab2died.github.io/jekyll-blog/content/database/2018/06/18/database.html" rel="alternate" type="text/html" title="Database" /><published>2018-06-18T23:15:27+08:00</published><updated>2018-06-18T23:15:27+08:00</updated><id>https://crab2died.github.io/jekyll-blog/content/database/2018/06/18/database</id><content type="html" xml:base="https://crab2died.github.io/jekyll-blog/content/database/2018/06/18/database.html">&lt;h2 id=&quot;一-四大特性ciad&quot;&gt;一. 四大特性(CIAD)&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;原子性(Atomicity): 要么全成功，要么全失败，失败会回滚。&lt;/li&gt;
  &lt;li&gt;一致性(Consistency): 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执
行之前和执行之后都必须处于一致性状态。&lt;/li&gt;
  &lt;li&gt;隔离性(Isolation): 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，
不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。&lt;/li&gt;
  &lt;li&gt;持久性(Durability): 一旦事物提交成功，那么数据库中的数据就是永久改变的，即使系统故障也不会丢失提交的事物。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二-数据库隔离级别&quot;&gt;二. 数据库隔离级别&lt;/h2&gt;
&lt;h3 id=&quot;1-不考虑隔离级别造成的问题&quot;&gt;1. 不考虑隔离级别造成的问题&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;更新丢失: 2个事物同时更新一条数据会有一个事物把另一个事物的更新覆盖了，这是因为系统没有任何操作隔离导致的.&lt;/li&gt;
  &lt;li&gt;脏读: 一个事物读取了另一个事物还未提交事物的数据&lt;/li&gt;
  &lt;li&gt;不可重复读: 一个事务对同一行数据重复读取两次，但是却得到了不同的结果
    &lt;ul&gt;
      &lt;li&gt;虚读: 一个事物去改变数据改变后发现还有数据为按要求改变，是因为另一事物也做了改变的缘故&lt;/li&gt;
      &lt;li&gt;幻读: 同一个事物内多次查询返回的结果不一致，是因为另一事物对数据进行了改变&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-隔离级别低---高&quot;&gt;2. 隔离级别(低 -&amp;gt; 高)&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Read uncommitted(未授权读取、读未提交)
    &lt;ul&gt;
      &lt;li&gt;当一个事物在执行写操作时，则不允许另一事物执行写操作，可执行其他操作，可由排他锁来实现&lt;/li&gt;
      &lt;li&gt;解决了更新丢失问题，但会出现脏读&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Read committed(授权读取、读提交)
    &lt;ul&gt;
      &lt;li&gt;读取数据事物允许其他事物继续访问该数据，但未提交的数据禁止其他事物访问&lt;/li&gt;
      &lt;li&gt;避免了脏读，但可能会出现幻读&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Repeatable read(可重复读取)
    &lt;ul&gt;
      &lt;li&gt;读数据的事物将禁止写事物(可以读事物),写事物将禁止所有其他事物&lt;/li&gt;
      &lt;li&gt;避免了脏读和不可重复读，但可能会出现幻读&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Serializable(序列化)
    &lt;ul&gt;
      &lt;li&gt;事物严格按照顺序一个一个执行&lt;/li&gt;
      &lt;li&gt;能避免所有情况，但会极大影响系统性能&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-扩展&quot;&gt;3. 扩展&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。&lt;br /&gt;
  Mysql的默认隔离级别就是Repeatable read。&lt;/li&gt;
  &lt;li&gt;MySQL数据库隔离级别管理
    &lt;ul&gt;
      &lt;li&gt;查看隔离级别: &lt;code class=&quot;highlighter-rouge&quot;&gt;select @@tx_isolation&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;修改隔离级别:  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;set [glogal | session] transaction isolation level 隔离级别名称&lt;/code&gt;&lt;br /&gt;
如&lt;code class=&quot;highlighter-rouge&quot;&gt;set transaction isolation level read-committed&lt;/code&gt;&lt;br /&gt;
或者
&lt;code class=&quot;highlighter-rouge&quot;&gt;set tx_isolation='隔离级别名称'&lt;/code&gt; 如 &lt;code class=&quot;highlighter-rouge&quot;&gt;set tx_isolation = 'read-committed'&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;隔离级别的设置只对当前连接有效&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-mysql悲观锁乐观锁共享锁与排他锁&quot;&gt;4. MySQL悲观锁、乐观锁、共享锁与排他锁&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;悲观锁: 在操作数据时都认为会出现数据冲突，所以每次都会去获取锁，只有获取锁后才能对数据操作。&lt;/li&gt;
  &lt;li&gt;乐观锁: 在操作数据都认为不会发生数据冲突，可以直接操作，一般由用户通过版本号自己实现。&lt;/li&gt;
  &lt;li&gt;共享锁: 共享锁指的就是对于多个不同的事务，对同一个资源共享同一个锁。在SQL后面加上&lt;code class=&quot;highlighter-rouge&quot;&gt;lock in share mode&lt;/code&gt;表示使用共享锁。&lt;/li&gt;
  &lt;li&gt;排他锁: 排它锁与共享锁相对应，就是指对于多个不同的事务，对同一个资源只能有一把锁。与共享锁类型，在需要执行的
语句后面加上&lt;code class=&quot;highlighter-rouge&quot;&gt;for update&lt;/code&gt;就可以了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三-数据库的三大范式normal-form&quot;&gt;三. 数据库的三大范式(Normal Form)&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;第一范式(1NF)：强调的是列的原子性，即列不能够再分成其他几列。&lt;/li&gt;
  &lt;li&gt;第二范式(2NF)：一个表必须有一个主键，二是其他列必须完全依赖于主键，而不能依赖主键一部分&lt;/li&gt;
  &lt;li&gt;第三范式(3NF)：非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列A依赖于非主键列B，非主键列B依赖于主键的情况。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四-数据库数据结构&quot;&gt;四. 数据库数据结构&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;B+ Tree
    &lt;ul&gt;
      &lt;li&gt;相较于B Tree多了一层，只有树的叶子节点存储实际数据，方便了range查询操作&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;五-mysql的myisam与innodb&quot;&gt;五. mysql的MyISAM与InnoDB&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;show engines&lt;/code&gt; 查看当前引擎与默认引擎&lt;/li&gt;
  &lt;li&gt;设置表引擎 CREATE后面加&lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE TABLE &quot;&quot; () ENGINE=MyISAM&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;alter table 表名 ENGINE = InnoDB&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;比较
    &lt;ul&gt;
      &lt;li&gt;MyISAM不支持事物,InnoDB支持&lt;/li&gt;
      &lt;li&gt;InnoDB支持行锁定,MyISAM不支持，只支持表锁定&lt;/li&gt;
      &lt;li&gt;InnoDB支持外键,MyISAM不支持&lt;/li&gt;
      &lt;li&gt;MyISAM支持全文检索,InnoDB不支持&lt;/li&gt;
      &lt;li&gt;MyISAM内置一个数据计数器，能很容易得出&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT COUNT(*) FROM TABLE_NAME&lt;/code&gt;结果&lt;/li&gt;
      &lt;li&gt;MyISAM索引数据与表数据分离，而InnoDB索引与表数据紧密关联&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;六-sql功能&quot;&gt;六. SQL功能&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;数据定义(DDL)：用于定义SQL模式、基本表、视图和索引的创建和撤消操作&lt;/li&gt;
  &lt;li&gt;数据操纵(DML)：数据操纵分成数据查询和数据更新两类。数据更新又分成插入、删除、和修改三种操作&lt;/li&gt;
  &lt;li&gt;数据控制：包括对基本表和视图的授权，完整性规则的描述，事务控制等内容&lt;/li&gt;
  &lt;li&gt;嵌入式SQL使用规定：涉及到SQL语句嵌入在宿主语言程序中使用的规则&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Crab2Died</name></author><category term="DataBase" /><summary type="html">一. 四大特性(CIAD) 原子性(Atomicity): 要么全成功，要么全失败，失败会回滚。 一致性(Consistency): 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执 行之前和执行之后都必须处于一致性状态。 隔离性(Isolation): 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务， 不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 持久性(Durability): 一旦事物提交成功，那么数据库中的数据就是永久改变的，即使系统故障也不会丢失提交的事物。 二. 数据库隔离级别 1. 不考虑隔离级别造成的问题 更新丢失: 2个事物同时更新一条数据会有一个事物把另一个事物的更新覆盖了，这是因为系统没有任何操作隔离导致的. 脏读: 一个事物读取了另一个事物还未提交事物的数据 不可重复读: 一个事务对同一行数据重复读取两次，但是却得到了不同的结果 虚读: 一个事物去改变数据改变后发现还有数据为按要求改变，是因为另一事物也做了改变的缘故 幻读: 同一个事物内多次查询返回的结果不一致，是因为另一事物对数据进行了改变 2. 隔离级别(低 -&amp;gt; 高) Read uncommitted(未授权读取、读未提交) 当一个事物在执行写操作时，则不允许另一事物执行写操作，可执行其他操作，可由排他锁来实现 解决了更新丢失问题，但会出现脏读 Read committed(授权读取、读提交) 读取数据事物允许其他事物继续访问该数据，但未提交的数据禁止其他事物访问 避免了脏读，但可能会出现幻读 Repeatable read(可重复读取) 读数据的事物将禁止写事物(可以读事物),写事物将禁止所有其他事物 避免了脏读和不可重复读，但可能会出现幻读 Serializable(序列化) 事物严格按照顺序一个一个执行 能避免所有情况，但会极大影响系统性能 3. 扩展 大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。 Mysql的默认隔离级别就是Repeatable read。 MySQL数据库隔离级别管理 查看隔离级别: select @@tx_isolation 修改隔离级别: set [glogal | session] transaction isolation level 隔离级别名称 如set transaction isolation level read-committed 或者 set tx_isolation='隔离级别名称' 如 set tx_isolation = 'read-committed' 隔离级别的设置只对当前连接有效</summary></entry><entry><title type="html">Java Compile and Optimize</title><link href="https://crab2died.github.io/jekyll-blog/content/java/2018/06/17/java-compile-and-optimize.html" rel="alternate" type="text/html" title="Java Compile and Optimize" /><published>2018-06-17T13:15:27+08:00</published><updated>2018-06-17T13:15:27+08:00</updated><id>https://crab2died.github.io/jekyll-blog/content/java/2018/06/17/java-compile-and-optimize</id><content type="html" xml:base="https://crab2died.github.io/jekyll-blog/content/java/2018/06/17/java-compile-and-optimize.html">&lt;h2 id=&quot;1-早期编译期优化&quot;&gt;1. 早期(编译期)优化&lt;/h2&gt;
&lt;h3 id=&quot;1-1-概论&quot;&gt;1-1. 概论&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;前端编译器:Sun的Javac、 Eclipse JDT中的增量式编译器(ECJ)
    &lt;ul&gt;
      &lt;li&gt;JIT编译器:HotSpot VM的C1、 C2编译器&lt;/li&gt;
      &lt;li&gt;AOT编译器:GNU Compiler for the Java(GCJ)、 Excelsior JET&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;javac这类编译器几乎不对代码进行性能优化,把性能优化放到了JIT即时编译器内,可为JRuby、
Groovy这类语言的代码也同等享有优化带来的好处&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1-2-javac编译&quot;&gt;1-2. javac编译&lt;/h3&gt;
&lt;h4 id=&quot;1-21-编译过程&quot;&gt;1-2.1. 编译过程&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;解析与填充符号表过程
    &lt;ul&gt;
      &lt;li&gt;词法、语法分析
        &lt;ul&gt;
          &lt;li&gt;词法分析是将源代码的字符流转变为标记(Token)集合,单个字符是程序编写过程的最小元素,而标记则是编译过程的最小元素,关键字、 变量名、 字面量、 运算符都可以成为标记&lt;/li&gt;
          &lt;li&gt;语法分析是根据Token序列构造抽象语法树的过程,抽象语法树(Abstract Syntax Tree,AST)是一种用来描述程序代码语法结构的树形表示方式,语法树的每一个节点都代表着程序
代码中的一个语法结构(Construct),例如包、 类型、 修饰符、 运算符、 接口、 返回值甚至代码注释等都可以是一个语法结构.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;填充符号表
        &lt;ul&gt;
          &lt;li&gt;符号表(Symbol Table)是由一组符号地址和符号信息构成的表格&lt;/li&gt;
          &lt;li&gt;在语义分析中,符号表所登记的内容将用于语义检查(如检查一个名字的使用和原先的说明是否一致)和产生中间代码.在目标代码生成阶段,当对符号名进行地址分配时,符号表是地址分配的依据.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;插入式注解处理器的注解处理过程&lt;/li&gt;
  &lt;li&gt;分析与字节码生成过程
    &lt;ul&gt;
      &lt;li&gt;标注检查
        &lt;ul&gt;
          &lt;li&gt;检查的内容包括诸如变量使用前是否已被声明、 变量与赋值之间的数据类型是否能够匹配等&lt;/li&gt;
          &lt;li&gt;常量折叠 如定义了 int a = 1 + 2 会被编译为 int a = 3&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;数据及控制流分析
        &lt;ul&gt;
          &lt;li&gt;数据及控制流分析是对程序上下文逻辑更进一步的验证,它可以检查出诸如程序局部变量在使用前是否有赋值、
 方法的每条路径是否都有返回值、 是否所有的受查异常都被正确处理了等问题.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;语法糖
        &lt;ul&gt;
          &lt;li&gt;语法糖:也称糖衣语法,是由英国计算机科学家彼得·约翰·兰达(Peter J.Landin)发明的一个术语,
 指在计算机语言中添加的某种语法,这种语法对语言的功能并没有影响,但是更方便程序员使用.
 通常来说,使用语法糖能够增加程序的可读性,从而减少程序代码出错的机会.&lt;/li&gt;
          &lt;li&gt;java语法糖:泛型、变长参数、 自动装箱/拆箱等 内部类、 枚举类、 断言语句、 对枚举和字符串(在JDK 1.7中支持)
 的switch支持、 try语句中定义和关闭资源(在JDK 1.7中支持)等&lt;/li&gt;
          &lt;li&gt;泛型:编译器会进行解泛,所以泛型不能进行方法重载&lt;/li&gt;
          &lt;li&gt;自动装箱、 拆箱与遍历循环&lt;/li&gt;
          &lt;li&gt;条件编译 if 的条件为常量时编译期会被执行&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;字节码生成
        &lt;ul&gt;
          &lt;li&gt;字节码生成阶段不仅仅是把前面各个步骤所生成的信息(语法树、 符号表)转化成字节码写到磁盘中,
 编译器还进行了少量的代码添加和转换工作.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-晚期运行期优化&quot;&gt;2. 晚期(运行期)优化&lt;/h2&gt;
&lt;h3 id=&quot;2-1-即时编译器jit&quot;&gt;2-1. 即时编译器(JIT)&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;为了提高热点代码的执行效率,在运行时,虚拟机将会把这些代码编译成与本地平台相关的机器码,并进行各种层次的优化,
完成这个任务的编译器称为即时编译器(Just In Time Compiler)&lt;/li&gt;
  &lt;li&gt;解释器与编译器(sun HotSpot虚拟机为例)
    &lt;ul&gt;
      &lt;li&gt;交互模型
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     |---------------即时编译-----------↓
     ↓                         Client Compiler(C1编译器)
  解释器(Interpreter)               编译器
     ↑                         Server Compiler(C2编译器)
     |----------------逆优化------------↑
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;HotSpot虚拟机同时由解释器与编译器搭配使用(成为混合模式(Mixed Model)),
可添加参数-Xint强制虚拟机使用解释模式(Interpreted Mode),可添加参数-Xcomp强制虚拟机使用编译模式(Compiled Mode)&lt;/li&gt;
      &lt;li&gt;启动参数-client启用Client Compiler编译器 参数-server启用Server Compiler编译器&lt;/li&gt;
      &lt;li&gt;HotSpot虚拟机还会逐渐启用分层编译(Tiered Compilation)的策略,分层编译的概念在JDK 1.6时期出现,
JDK1.7中Server模式中默认开启,之前需配参数-XX:+TieredCompilation启用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;编译对象与触发条件
    &lt;ul&gt;
      &lt;li&gt;触发条件
        &lt;ul&gt;
          &lt;li&gt;被多次调用的方法&lt;/li&gt;
          &lt;li&gt;被多次执行的循环体,这个称为栈上替换(On Stack Replacement,简称为OSR编译)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;热点代码判定
        &lt;ul&gt;
          &lt;li&gt;基于采样的热点探测,周期性检测个线程的栈顶,若某个方法经常在栈顶,则认为是热点方法；
 优点是实现简单简单,高效,容易获取方法调用关系,缺点是不能准确判定一个方法的热度&lt;/li&gt;
          &lt;li&gt;基于计数器的热点探测,虚拟机为每个方法设定计数器,统计方法执行次数,若超过一定阈值则认为是热点方法；
 优点是能准确判定一个方法的热度,缺点是要为每个方法建立计数器并维护,实现麻烦,也不能获取方法的调用关系&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;HotSpot虚拟机是基于计数器的热点探测,有2个计数器:方法调用计数器(Invocation Counter)和回边计数器(Back Edge Counter)
        &lt;ul&gt;
          &lt;li&gt;方法调用计数器,Client模式下阈值为1500次,Server模式下阈值为1000次,可由参数-XX:CompileThreshold来设置
 -XX:-UseCounterDecay设置关闭热度衰减,-XX:CounterHalfLifeTime参数设置半衰周期的时间,单位是秒&lt;/li&gt;
          &lt;li&gt;回边计数器,参数-XX:OnStackReplacePercentage来间接调整回边计数器的阈值
 Client模式下阈值计算公式:
 方法调用计数器阈值(CompileThreshold)×OSR比率(OnStackReplacePercentage)[默认值为933]/100 默认情况下为13995
 Server模式下阈值计算公式:
 方法调用计数器阈值(CompileThreshold)×(OSR比率(OnStackReplacePercentage)[默认值140]-解释器监控比率(InterpreterProfilePercentage)[默认值33]/100 
 默认情况下为10700&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;编译过程
    &lt;ul&gt;
      &lt;li&gt;Client模式下编译过程&lt;br /&gt;
 &lt;img src=&quot;https://raw.githubusercontent.com/Crab2died/jdepth/master/src/main/java/com/github/jvm/optimize/Client-Compiler%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png&quot; alt=&quot;Client Compiler编译过程&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Server模式下编译过程&lt;br /&gt;
 相当复杂&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;优化技术
    &lt;ul&gt;
      &lt;li&gt;公共子表达式消除
        &lt;ul&gt;
          &lt;li&gt;经典优化技术,如果一个表达式E已经计算过了,并且从先前的计算到现在E中所有变量的值都没有发生变化,
 那么E的这次出现就成为了公共子表达式. 对于这种表达式,没有必要花时间再对它进行计算,只需要直接用前面计算过的表达式结果代替E就可以了&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;数组边界检查消除
        &lt;ul&gt;
          &lt;li&gt;语言相关的其他消除操作还有不少,如自动装箱消除(Autobox Elimination)、 安全点消除(Safepoint Elimination)、消除反射(Dereflection)等&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;方法内联
        &lt;ul&gt;
          &lt;li&gt;虚拟机最重要的优化手段之一,除了消除方法调用的成本之外,它更重要的意义是为其他优化手段建立良好的基础&lt;/li&gt;
          &lt;li&gt;非虚方法直接内联,虚方法引入了一种名为“类型继承关系分析”(Class Hierarchy Analysis,CHA)的技术,
 检查发现没有多个目标版本可供选择,则也可内联,但需准备一个逃生门,即使有多个版本目标也会默认内联,但在调用时要检查,
 发现版本目标不一致在取消内联,会从“逃生门”回到解释状态重新执行&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;逃逸分析(JDK1.6)
        &lt;ul&gt;
          &lt;li&gt;当下java最前沿的优化技术&lt;/li&gt;
          &lt;li&gt;逃逸分析的基本行为就是分析对象动态作用域:当一个对象在方法中被定义后,它可能被外部方法所引用,
 例如作为调用参数传递到其他方法中,称为方法逃逸. 甚至还有可能被外部线程访问到,
 譬如赋值给类变量或可以在其他线程中访问的实例变量,称为线程逃逸.&lt;/li&gt;
          &lt;li&gt;栈上分配(Stack Allocation),如果证明一个对象不会逃逸到方法之外,则可以将对象分配到方法栈帧内存,这样随着栈帧出栈而销毁,极大地降低了GC系统压力&lt;/li&gt;
          &lt;li&gt;同步消除(Synchronization Elimination),如果能证明一个变量不会逃逸出线程,那就可以消除掉同步措施,消除同步带来的消耗&lt;/li&gt;
          &lt;li&gt;标量替换(Scalar Replacement)
 标量(Scalar),是指一个数据已经无法再分解成更小的数据来表示了,如:int,long,double等
 聚合量(Aggregate),是指一个数据可以被分解,典型的java对象
 如果证明一个对象不被外界访问,又可拆散的话,那程序在调用的时候就不创建该变量,改为创建多个成员变量来代替,
 将对象拆分后,除了可以让对象的成员变量在栈上(栈上存储的数据,有很大的概率会被虚拟机分配至物理机器的高速寄存器中存储)
 分配和读写之外,还可以为后续进一步的优化手段创建条件&lt;/li&gt;
          &lt;li&gt;逃逸分析尚不成熟&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Crab2Died</name></author><category term="Java" /><category term="JIT" /><category term="Optimize" /><summary type="html">1. 早期(编译期)优化 1-1. 概论 前端编译器:Sun的Javac、 Eclipse JDT中的增量式编译器(ECJ) JIT编译器:HotSpot VM的C1、 C2编译器 AOT编译器:GNU Compiler for the Java(GCJ)、 Excelsior JET javac这类编译器几乎不对代码进行性能优化,把性能优化放到了JIT即时编译器内,可为JRuby、 Groovy这类语言的代码也同等享有优化带来的好处 1-2. javac编译 1-2.1. 编译过程 解析与填充符号表过程 词法、语法分析 词法分析是将源代码的字符流转变为标记(Token)集合,单个字符是程序编写过程的最小元素,而标记则是编译过程的最小元素,关键字、 变量名、 字面量、 运算符都可以成为标记 语法分析是根据Token序列构造抽象语法树的过程,抽象语法树(Abstract Syntax Tree,AST)是一种用来描述程序代码语法结构的树形表示方式,语法树的每一个节点都代表着程序 代码中的一个语法结构(Construct),例如包、 类型、 修饰符、 运算符、 接口、 返回值甚至代码注释等都可以是一个语法结构. 填充符号表 符号表(Symbol Table)是由一组符号地址和符号信息构成的表格 在语义分析中,符号表所登记的内容将用于语义检查(如检查一个名字的使用和原先的说明是否一致)和产生中间代码.在目标代码生成阶段,当对符号名进行地址分配时,符号表是地址分配的依据. 插入式注解处理器的注解处理过程 分析与字节码生成过程 标注检查 检查的内容包括诸如变量使用前是否已被声明、 变量与赋值之间的数据类型是否能够匹配等 常量折叠 如定义了 int a = 1 + 2 会被编译为 int a = 3 数据及控制流分析 数据及控制流分析是对程序上下文逻辑更进一步的验证,它可以检查出诸如程序局部变量在使用前是否有赋值、 方法的每条路径是否都有返回值、 是否所有的受查异常都被正确处理了等问题. 语法糖 语法糖:也称糖衣语法,是由英国计算机科学家彼得·约翰·兰达(Peter J.Landin)发明的一个术语, 指在计算机语言中添加的某种语法,这种语法对语言的功能并没有影响,但是更方便程序员使用. 通常来说,使用语法糖能够增加程序的可读性,从而减少程序代码出错的机会. java语法糖:泛型、变长参数、 自动装箱/拆箱等 内部类、 枚举类、 断言语句、 对枚举和字符串(在JDK 1.7中支持) 的switch支持、 try语句中定义和关闭资源(在JDK 1.7中支持)等 泛型:编译器会进行解泛,所以泛型不能进行方法重载 自动装箱、 拆箱与遍历循环 条件编译 if 的条件为常量时编译期会被执行 字节码生成 字节码生成阶段不仅仅是把前面各个步骤所生成的信息(语法树、 符号表)转化成字节码写到磁盘中, 编译器还进行了少量的代码添加和转换工作. 2. 晚期(运行期)优化 2-1. 即时编译器(JIT) 为了提高热点代码的执行效率,在运行时,虚拟机将会把这些代码编译成与本地平台相关的机器码,并进行各种层次的优化, 完成这个任务的编译器称为即时编译器(Just In Time Compiler) 解释器与编译器(sun HotSpot虚拟机为例) 交互模型 |---------------即时编译-----------↓ ↓ Client Compiler(C1编译器) 解释器(Interpreter) 编译器 ↑ Server Compiler(C2编译器) |----------------逆优化------------↑ HotSpot虚拟机同时由解释器与编译器搭配使用(成为混合模式(Mixed Model)), 可添加参数-Xint强制虚拟机使用解释模式(Interpreted Mode),可添加参数-Xcomp强制虚拟机使用编译模式(Compiled Mode) 启动参数-client启用Client Compiler编译器 参数-server启用Server Compiler编译器 HotSpot虚拟机还会逐渐启用分层编译(Tiered Compilation)的策略,分层编译的概念在JDK 1.6时期出现, JDK1.7中Server模式中默认开启,之前需配参数-XX:+TieredCompilation启用 编译对象与触发条件 触发条件 被多次调用的方法 被多次执行的循环体,这个称为栈上替换(On Stack Replacement,简称为OSR编译) 热点代码判定 基于采样的热点探测,周期性检测个线程的栈顶,若某个方法经常在栈顶,则认为是热点方法； 优点是实现简单简单,高效,容易获取方法调用关系,缺点是不能准确判定一个方法的热度 基于计数器的热点探测,虚拟机为每个方法设定计数器,统计方法执行次数,若超过一定阈值则认为是热点方法； 优点是能准确判定一个方法的热度,缺点是要为每个方法建立计数器并维护,实现麻烦,也不能获取方法的调用关系 HotSpot虚拟机是基于计数器的热点探测,有2个计数器:方法调用计数器(Invocation Counter)和回边计数器(Back Edge Counter) 方法调用计数器,Client模式下阈值为1500次,Server模式下阈值为1000次,可由参数-XX:CompileThreshold来设置 -XX:-UseCounterDecay设置关闭热度衰减,-XX:CounterHalfLifeTime参数设置半衰周期的时间,单位是秒 回边计数器,参数-XX:OnStackReplacePercentage来间接调整回边计数器的阈值 Client模式下阈值计算公式: 方法调用计数器阈值(CompileThreshold)×OSR比率(OnStackReplacePercentage)[默认值为933]/100 默认情况下为13995 Server模式下阈值计算公式: 方法调用计数器阈值(CompileThreshold)×(OSR比率(OnStackReplacePercentage)[默认值140]-解释器监控比率(InterpreterProfilePercentage)[默认值33]/100 默认情况下为10700 编译过程 Client模式下编译过程 Server模式下编译过程 相当复杂 优化技术 公共子表达式消除 经典优化技术,如果一个表达式E已经计算过了,并且从先前的计算到现在E中所有变量的值都没有发生变化, 那么E的这次出现就成为了公共子表达式. 对于这种表达式,没有必要花时间再对它进行计算,只需要直接用前面计算过的表达式结果代替E就可以了 数组边界检查消除 语言相关的其他消除操作还有不少,如自动装箱消除(Autobox Elimination)、 安全点消除(Safepoint Elimination)、消除反射(Dereflection)等 方法内联 虚拟机最重要的优化手段之一,除了消除方法调用的成本之外,它更重要的意义是为其他优化手段建立良好的基础 非虚方法直接内联,虚方法引入了一种名为“类型继承关系分析”(Class Hierarchy Analysis,CHA)的技术, 检查发现没有多个目标版本可供选择,则也可内联,但需准备一个逃生门,即使有多个版本目标也会默认内联,但在调用时要检查, 发现版本目标不一致在取消内联,会从“逃生门”回到解释状态重新执行 逃逸分析(JDK1.6) 当下java最前沿的优化技术 逃逸分析的基本行为就是分析对象动态作用域:当一个对象在方法中被定义后,它可能被外部方法所引用, 例如作为调用参数传递到其他方法中,称为方法逃逸. 甚至还有可能被外部线程访问到, 譬如赋值给类变量或可以在其他线程中访问的实例变量,称为线程逃逸. 栈上分配(Stack Allocation),如果证明一个对象不会逃逸到方法之外,则可以将对象分配到方法栈帧内存,这样随着栈帧出栈而销毁,极大地降低了GC系统压力 同步消除(Synchronization Elimination),如果能证明一个变量不会逃逸出线程,那就可以消除掉同步措施,消除同步带来的消耗 标量替换(Scalar Replacement) 标量(Scalar),是指一个数据已经无法再分解成更小的数据来表示了,如:int,long,double等 聚合量(Aggregate),是指一个数据可以被分解,典型的java对象 如果证明一个对象不被外界访问,又可拆散的话,那程序在调用的时候就不创建该变量,改为创建多个成员变量来代替, 将对象拆分后,除了可以让对象的成员变量在栈上(栈上存储的数据,有很大的概率会被虚拟机分配至物理机器的高速寄存器中存储) 分配和读写之外,还可以为后续进一步的优化手段创建条件 逃逸分析尚不成熟</summary></entry><entry><title type="html">Java GC</title><link href="https://crab2died.github.io/jekyll-blog/content/java/2018/06/15/java-gc.html" rel="alternate" type="text/html" title="Java GC" /><published>2018-06-15T13:15:27+08:00</published><updated>2018-06-15T13:15:27+08:00</updated><id>https://crab2died.github.io/jekyll-blog/content/java/2018/06/15/java-gc</id><content type="html" xml:base="https://crab2died.github.io/jekyll-blog/content/java/2018/06/15/java-gc.html">&lt;h2 id=&quot;一-java虚拟机内存区域&quot;&gt;一. Java虚拟机内存区域&lt;/h2&gt;
&lt;h3 id=&quot;1-运行时数据区&quot;&gt;1. 运行时数据区&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Crab2died/jdepth/master/src/main/java/com/github/jvm/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png&quot; alt=&quot;java运行时数据区&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-程序计数器program-counter-register&quot;&gt;2. 程序计数器(Program Counter Register)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、程序计数器是线程内(每个线程都有唯一的、封闭的)一小块内存区域&lt;/li&gt;
  &lt;li&gt;2、计数器指定的是当前虚拟机执行指令的地址&lt;/li&gt;
  &lt;li&gt;3、当虚拟机执行的是Native方法时,计数器值为空(Undefined),此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError
   情况的区域.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-java虚拟机栈java-virtual-machine-stacks&quot;&gt;3. Java虚拟机栈(Java Virtual Machine Stacks)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、虚拟机栈是线程内部的、封闭的&lt;/li&gt;
  &lt;li&gt;2、虚拟机栈描述的是java方法执行的内存模型&lt;/li&gt;
  &lt;li&gt;3、每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、 操作数栈、 动态链接、 方法出口等信息&lt;/li&gt;
  &lt;li&gt;4、java方法的执行就是入栈与出栈的过程&lt;/li&gt;
  &lt;li&gt;5、如果虚拟机栈深度超出了虚拟机允许深度将会抛出StackOverflowError异常,现代虚拟机大多数支持动态扩展(也允许固定长度),当虚拟机申
   请扩展时申请不到足够的内存时,将会抛出OutOfMemoryError异常&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-本地方法栈native-method-stack&quot;&gt;4. 本地方法栈(Native Method Stack)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、为虚拟机调用本地Native方法提供服务&lt;/li&gt;
  &lt;li&gt;2、也有虚拟机(譬如Sun HotSpot虚拟机)直接就把本地方法栈和虚拟机栈合二为一&lt;/li&gt;
  &lt;li&gt;3、也会抛出StackOverflowError异常和OutOfMemoryError异常&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-java堆java-heap-gc堆&quot;&gt;5. Java堆(Java Heap) GC堆&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、线程共享的最大一块内存区域&lt;/li&gt;
  &lt;li&gt;2、此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存,虚拟机规范所有的对象实例与数据都在堆上分配&lt;/li&gt;
  &lt;li&gt;3、随着JIT编译器的发展与逃逸分析技术逐渐成熟,栈上分配、 标量替换优化技术将会导致一些微妙的变化发生,所有的对象都分配在堆上也渐渐
   变得不是那么“绝对”了&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6-方法区method-area&quot;&gt;6. 方法区(Method Area)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、存储已被虚拟机加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据&lt;/li&gt;
  &lt;li&gt;2、这区域的内存回收目标主要是针对常量池的回收和对类型的卸载&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;7-运行时常量池runtime-constant-pool&quot;&gt;7. 运行时常量池(Runtime Constant Pool)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、Class文件中除了有类的版本、 字段、 方法、 接口等描述信息外,还有一项信息是常量池(Constant Pool Table),用于存放编译期生成
   的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放&lt;/li&gt;
  &lt;li&gt;2、String.intern()也会放入运行时常量池中&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8-直接内存direct-memory&quot;&gt;8. 直接内存(Direct Memory)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、NIO的DirectByteBuffer对象使用直接内存,这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;二-java对象&quot;&gt;二. Java对象&lt;/h2&gt;
&lt;h3 id=&quot;1-对象的创建&quot;&gt;1. 对象的创建&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、指针碰撞(Bump the Pointer)&lt;/li&gt;
  &lt;li&gt;2、空闲列表(Free List)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-对象再内存中的布局&quot;&gt;2. 对象再内存中的布局&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、分为3块区域:对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)&lt;/li&gt;
  &lt;li&gt;2、对象头包含:轻量级锁定、 重量级锁定、 GC标记、 可偏向&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-对象的访问定位&quot;&gt;3. 对象的访问定位&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、句柄访问&lt;br /&gt;
 &lt;img src=&quot;https://raw.githubusercontent.com/Crab2died/jdepth/master/src/main/java/com/github/jvm/gc/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.png&quot; alt=&quot;句柄访问对象&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;2、直接指针访问 &lt;br /&gt;
 &lt;img src=&quot;https://raw.githubusercontent.com/Crab2died/jdepth/master/src/main/java/com/github/jvm/gc/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.png&quot; alt=&quot;直接指针访问&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三-垃圾回收与内存分配&quot;&gt;三. 垃圾回收与内存分配&lt;/h2&gt;
&lt;h3 id=&quot;1-引用计数法虚拟机未使用&quot;&gt;1. 引用计数法(虚拟机未使用)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、互相引用将无法得到正常回收&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-可达性分析算法reachability-analysis&quot;&gt;2. 可达性分析算法(Reachability Analysis)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、通过GC Root节点向下搜索,搜索走过的路径称为引用链(Reference Chain),当一个对象没有一个引用链经过,则表示该对象是不可用的,可以回收&lt;/li&gt;
  &lt;li&gt;2、可作为GC Root对象的有:
    &lt;ul&gt;
      &lt;li&gt;虚拟机栈(栈帧中的本地变量表)中引用的对象&lt;/li&gt;
      &lt;li&gt;方法区中类静态属性引用的对象&lt;/li&gt;
      &lt;li&gt;方法区中常量引用的对象&lt;/li&gt;
      &lt;li&gt;本地方法栈中JNI(即一般说的Native方法)引用的对象&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-引用&quot;&gt;3. 引用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、强引用(Strong Reference): new 关键字&lt;/li&gt;
  &lt;li&gt;2、软引用(Soft Reference):当要发生内存溢出时会将软引用对象加入回收队列中&lt;/li&gt;
  &lt;li&gt;3、弱引用(Weak Reference):只能活到下次GC前&lt;/li&gt;
  &lt;li&gt;4、虚引用(Phantom Reference):幽灵引用或者幻影引用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-回收方法区&quot;&gt;4. 回收方法区&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、主要回收永久代的废弃的常量和无用的类&lt;/li&gt;
  &lt;li&gt;2、无用的类判定条件:
    &lt;ul&gt;
      &lt;li&gt;该类所有的实例都已经被回收,也就是Java堆中不存在该类的任何实例.&lt;/li&gt;
      &lt;li&gt;加载该类的ClassLoader已经被回收.&lt;/li&gt;
      &lt;li&gt;该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四-垃圾回收算法&quot;&gt;四. 垃圾回收算法&lt;/h2&gt;
&lt;h3 id=&quot;1-标记-清除算法mark-sweep&quot;&gt;1. 标记-清除算法(Mark-Sweep)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、标记与清除2个过程&lt;/li&gt;
  &lt;li&gt;2、标记与清除效率都不高,还可能产生大量空间碎片导致大对象找不到连续可用的空间&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-复制算法copying&quot;&gt;2. 复制算法(Copying)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、将堆内存分为大小相等的2块,每次只是用其中一块,当一块内存用完时将还活着的对象移动到另一块,然后清理该块内存&lt;/li&gt;
  &lt;li&gt;2、消除了内存碎片化,代价是牺牲了一半可用堆内存&lt;/li&gt;
  &lt;li&gt;3、商用虚拟机都采用这种,但并不是按1:1来划分空间而是将内存分为一块较大的Eden空间和两块较小的Survivor空间,每次使用Eden和其中
   一块Survivor.当回收时,将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上,最后清理掉Eden和刚才用过的
   Survivor空间. HotSpot虚拟机默认Eden和Survivor的大小比例是8:1,也就是每次新生代中可用内存空间为整个新生代容量的
   90%(80%+10%),只有10%的内存会被“浪费”. 当然,98%的对象可回收只是一般场景下的数据,我们没有办法保证每次回收都只有不多于
   10%的对象存活,当Survivor空间不够用时,需要依赖其他内存(这里指老年代)进行分配担保(Handle Promotion).&lt;/li&gt;
  &lt;li&gt;4、当存活率高时将会出现大量的内存复制操作还有可能导致进行分配担保&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-标记-整理算法mark-compact&quot;&gt;3. 标记-整理算法(Mark-Compact)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、老年代内存,标记可回收对象之后,将存活的对象移向一端,然后清理掉端边界以外的内存&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-分代收集算法generational-collection&quot;&gt;4. 分代收集算法(Generational Collection)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、将堆内存分为老年代和新生代&lt;/li&gt;
  &lt;li&gt;2、老年代对象存活率高,再采用标记-清理或标记-整理算法进行GC&lt;/li&gt;
  &lt;li&gt;3、新生代存活率低,采用复制算法将少量的存活对象进行复制操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;五-hotspot算法实现&quot;&gt;五. HotSpot算法实现&lt;/h2&gt;
&lt;h3 id=&quot;1-枚举根节点&quot;&gt;1. 枚举根节点&lt;/h3&gt;
&lt;p&gt;  - 1、虚拟机内OopMap存有对象引用信息，可以得到GC Root根节点&lt;/p&gt;

&lt;h3 id=&quot;2-安全点&quot;&gt;2. 安全点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、虚拟机会在如方法调用、 循环跳转、 异常跳转等，所以具有这些功能的指令才会产生Safepoint&lt;/li&gt;
  &lt;li&gt;2、中断方式
    &lt;ul&gt;
      &lt;li&gt;抢先式中断(基本弃用): 给出中断指令，有线程发现未到达安全点则继续执行至下一个安全点&lt;/li&gt;
      &lt;li&gt;主动式中断: 给定一个中断标志，每个线程都会去轮询该标志，为真时中断&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-安全区域&quot;&gt;3. 安全区域&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、安全区域是指在一段代码片段之中，引用关系不会发生变化。 在这个区域中的任意地方开始GC都是安全的&lt;/li&gt;
  &lt;li&gt;2、在线程执行到安全区域时首先会标记自己进入安全区域，出安全区域前必须等到枚举根节点或整个GC完成，没有则都等到可以出安全区域信号为止&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;六-垃圾回收器&quot;&gt;六. 垃圾回收器&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Crab2died/jdepth/master/src/main/java/com/github/jvm/gc/HotSpot%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png&quot; alt=&quot;HotSpot虚拟机垃圾回收器&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-serial收集器&quot;&gt;1. Serial收集器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、JDK1.3.1之前是虚拟机新生代收集的唯一选择&lt;/li&gt;
  &lt;li&gt;2、单线程、Stop The World(STW)、复制算法&lt;/li&gt;
  &lt;li&gt;3、Client模式下新生代默认的垃圾收集器&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-pernew收集器&quot;&gt;2. PerNew收集器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、Serial收集器的多线程版,其他一样&lt;/li&gt;
  &lt;li&gt;2、是许多虚拟机Server模式下新生代的首选收集器&lt;/li&gt;
  &lt;li&gt;3、ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器,也可以使用-XX:+UseParNewGC选项来强制指定它&lt;/li&gt;
  &lt;li&gt;4、单核下效果不一定比Serial效果好,多核更适合,-XX:ParallelGCThreads参数来限制垃圾收集的线程数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-parallel-scavenge收集器&quot;&gt;3. Parallel Scavenge收集器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、新生代收集器,采用复制算法,并行的多线程收集器,吞吐量优先&lt;/li&gt;
  &lt;li&gt;2、追求可控的吞吐量, 吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)&lt;/li&gt;
  &lt;li&gt;3、控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-serial-old收集器&quot;&gt;4. Serial Old收集器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、Serial老年代版本、单线程、标记-整理算法&lt;/li&gt;
  &lt;li&gt;2、给Client模式下虚拟机用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-parallel-old收集器&quot;&gt;5. Parallel Old收集器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、Parallel Scavenge收集器的老年代版本,使用多线程和“标记-整理”算法,JDK1.6开始提供&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6-cms收集器&quot;&gt;6. CMS收集器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器.&lt;/li&gt;
  &lt;li&gt;2、标记-清除算法实现
    &lt;ul&gt;
      &lt;li&gt;初始标记(CMS initial mark)，有短时的STW&lt;/li&gt;
      &lt;li&gt;并发标记(CMS concurrent mark)&lt;/li&gt;
      &lt;li&gt;重新标记(CMS remark)，有短时的STW&lt;/li&gt;
      &lt;li&gt;并发清除(CMS concurrent sweep)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3、并发收集、 低停顿,Sun公司的一些官方文档中也称之为并发低停顿收集器&lt;/li&gt;
  &lt;li&gt;4、-XX：+UseCMSCompactAtFullCollection默认开启，表示CMS进行Full GC的时候开启内存碎片的合并整理，该过程无法并发停顿时间变长&lt;/li&gt;
  &lt;li&gt;5、-XX：CMSFullGCsBeforeCompaction表示执行多少次不压缩的Full GC后跟着来一次压缩的Full GC，默认是0，每次都压缩&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;7-g1收集器&quot;&gt;7. G1收集器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、G1(Garbage-First)收集器是当今收集器技术发展的最前沿成果之一,面向服务端应用&lt;/li&gt;
  &lt;li&gt;2、特点:
    &lt;ul&gt;
      &lt;li&gt;并发与并行:充分利用cpu与多核等硬件优势&lt;/li&gt;
      &lt;li&gt;分代收集:&lt;/li&gt;
      &lt;li&gt;空间整理:标记-整理算法&lt;/li&gt;
      &lt;li&gt;可预测的停顿:将堆内存分为多个区域(Region),还保留有老年代与新生代&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3、不计算维护Remembered Set的操作,G1收集器的运作大致可划分为以下几个步骤:
    &lt;ul&gt;
      &lt;li&gt;初始标记(Initial Marking)&lt;/li&gt;
      &lt;li&gt;并发标记(Concurrent Marking)&lt;/li&gt;
      &lt;li&gt;最终标记(Final Marking)&lt;/li&gt;
      &lt;li&gt;筛选回收(Live Data Counting and Evacuation)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8-垃圾收集器参数&quot;&gt;8. 垃圾收集器参数&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;参数&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;UseSerialGC&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Client模式下默认,使用Serial+Serial Old组合&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;UseParNewGC&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ParNew+Serial Old组合&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;UseConMarkSweepGC&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ParNew+CMS+Serial Old组合,Serial Old作为CMS失败后备用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;UseParallelGC&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Server模式默认,Parallel Scavenge+Serial Old(PS Mark Sweep)组合&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;UseParallelOldGC&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Parallel Scavenge+Parallel Old组合&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;UseG1GC&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;使用G1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;七-内存分配与回收策略&quot;&gt;七. 内存分配与回收策略&lt;/h2&gt;
&lt;h3 id=&quot;1-对象优先在eden分配&quot;&gt;1. 对象优先在Eden分配&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;对象优先在Eden新生代分配,内存不足将发生一次Minor GC&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-大对象直接进入老年代&quot;&gt;2. 大对象直接进入老年代&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;-XX:PretenureSizeThreshold参数,令大于这个设置值的对象直接在老年代分配,避免大量内存复制&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-长期存活的对象将进入老年代&quot;&gt;3. 长期存活的对象将进入老年代&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;对象晋升老年代的年龄阈值,可以通过参数-XX:MaxTenuringThreshold设置,默认15,每次Minor GC对象没死+1&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-动态对象年龄判定&quot;&gt;4. 动态对象年龄判定&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代,无须等
到MaxTenuringThreshold中要求的年龄&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-空间分配担保&quot;&gt;5. 空间分配担保&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Minor GC前先判断老年代可用空间是否大于新生代对象总空间,如果大于则确保安全,如果小于则查看HandlePromotionFailure设置的值是否
允许担保失败,若允许则会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小,如果大于,将尝试着进行一次Minor 
GC,尽管这次Minor GC是有风险的;如果小于,或者HandlePromotionFailure设置不允许冒险,那这时也要改为进行一次Full GC.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;八-minor-gcmajor-gc与full-gc&quot;&gt;八. Minor GC、Major GC与Full GC&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Minor GC表示新生代GC、Major GC是指老年代GC、Full GC为全部堆内存GC。&lt;/li&gt;
  &lt;li&gt;往往他们之间相互影响，相互触发&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Crab2Died</name></author><category term="Java" /><category term="GC" /><summary type="html">一. Java虚拟机内存区域 1. 运行时数据区</summary></entry><entry><title type="html">Java Concurrent</title><link href="https://crab2died.github.io/jekyll-blog/content/java/2018/06/15/java-concurrent.html" rel="alternate" type="text/html" title="Java Concurrent" /><published>2018-06-15T13:15:27+08:00</published><updated>2018-06-15T13:15:27+08:00</updated><id>https://crab2died.github.io/jekyll-blog/content/java/2018/06/15/java-concurrent</id><content type="html" xml:base="https://crab2died.github.io/jekyll-blog/content/java/2018/06/15/java-concurrent.html">&lt;h2 id=&quot;1-java与线程&quot;&gt;1. JAVA与线程&lt;/h2&gt;
&lt;h3 id=&quot;11-线程的实现&quot;&gt;1.1 线程的实现&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;实现方式:使用内核线程实现、 使用用户线程实现和使用用户线程加轻量级进程混合实现.&lt;/li&gt;
  &lt;li&gt;JDK1.2之前是基于用户线程实现的，JDK1.2及以后是基于操作系统原生线程模型实现的.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;12-java线程调度&quot;&gt;1.2 Java线程调度&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;线程调度是指系统为线程分配处理器使用权的过程,主要调度方式有两种,分别是协同式线程调度(Cooperative Threads-Scheduling)
和抢占式线程调度(Preemptive ThreadsScheduling)&lt;/li&gt;
  &lt;li&gt;协同式线程调度:线程的执行时间由线程本身来控制,线程把自己的工作执行完了之后,要主动通知系统切换到另外一个线程上;
优点是实现简单,缺点是线程执行时间不可控制,容易线程阻塞&lt;/li&gt;
  &lt;li&gt;每个线程将由系统来分配执行时间,线程的切换不由线程本身来决定(在Java中,Thread.yield()可以让出执行时间,但是要获取执行时
间的话,线程本身是没有什么办法的);优点是线程的执行时间是系统可控的,也不会有一个线程导致整个进程阻塞的问题.&lt;/li&gt;
  &lt;li&gt;JAVA线程有10个优先级(Thread.MIN_PRIORITY至Thread.MAX_PRIORITY)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;13-线程转换状态&quot;&gt;1.3 线程转换状态&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;JAVA线程定义了6个状态:
    &lt;ul&gt;
      &lt;li&gt;新建(New):创建后尚未启动的线程处于这种状态.&lt;/li&gt;
      &lt;li&gt;运行(Runable):Runable包括了操作系统线程状态中的Running和Ready,也就是处于此状态的线程有可能正在执行,也有可能正在
等待着CPU为它分配执行时间.&lt;/li&gt;
      &lt;li&gt;无限期等待(Waiting):处于这种状态的线程不会被分配CPU执行时间,它们要等待被&lt;br /&gt;
    其他线程显式地唤醒. 以下方法会让线程陷入无限期的等待状态:&lt;br /&gt;
    ● 没有设置Timeout参数的Object.wait()方法.&lt;br /&gt;
    ● 没有设置Timeout参数的Thread.join()方法.&lt;br /&gt;
    ● LockSupport.park()方法.&lt;/li&gt;
      &lt;li&gt;限期等待(Timed Waiting):处于这种状态的线程也不会被分配CPU执行时间,不过无须等待被其他线程显式地唤醒,在一定时间之后
它们会由系统自动唤醒. 以下方法会让线程进入限期等待状态:&lt;br /&gt;
    ● Thread.sleep()方法.&lt;br /&gt;
    ● 设置了Timeout参数的Object.wait()方法.&lt;br /&gt;
    ● 设置了Timeout参数的Thread.join()方法.&lt;br /&gt;
    ● LockSupport.parkNanos()方法.&lt;br /&gt;
    ● LockSupport.parkUntil()方法&lt;/li&gt;
      &lt;li&gt;阻塞(Blocked):该状态程序在等待获取一个排他锁，程序在同步时会在该状态&lt;/li&gt;
      &lt;li&gt;结束(Terminated):已终止线程的线程状态,线程已经结束执行.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;线程状态转换关系图&lt;br /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/Crab2died/jdepth/master/src/main/java/com/github/jvm/concurrent/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.png&quot; alt=&quot;线程状态转换关系&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-线程安全与锁优化&quot;&gt;2. 线程安全与锁优化&lt;/h2&gt;
&lt;h3 id=&quot;21-java中的线程安全&quot;&gt;2.1 JAVA中的线程安全&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;共享数据分类
    &lt;ul&gt;
      &lt;li&gt;不可变(Immutable):不可变对象一定是线程安全的,典型的final&lt;/li&gt;
      &lt;li&gt;绝对线程安全:&lt;/li&gt;
      &lt;li&gt;相对线程安全: java大部分的线程安全都是相对线程安全的&lt;/li&gt;
      &lt;li&gt;线程兼容:&lt;/li&gt;
      &lt;li&gt;线程对立:&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22-synchronized的优化&quot;&gt;2.2 synchronized的优化&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;synchronized自JDK1.6后引入偏向锁和轻量级锁后大大提升了并发的性能&lt;/li&gt;
  &lt;li&gt;synchronized锁升级&lt;code class=&quot;highlighter-rouge&quot;&gt;偏向锁 -&amp;gt; 轻量级锁 -&amp;gt; 重量级锁&lt;/code&gt; 所以在锁高竞争下Lock性能更高&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-锁介绍&quot;&gt;3. 锁介绍&lt;/h2&gt;
&lt;h3 id=&quot;31-自旋锁&quot;&gt;3.1 自旋锁&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;自旋锁可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环，（即所谓的自旋，就是自己执行空循环），若在若干个空循环后，线程
如果可以获得锁，则继续执行。若线程依然不能获得锁，才会被挂起。使用自旋锁后，线程被挂起的几率相对减少，线程执行的连贯性相对加强。因
此，对于那些锁竞争不是很激烈，锁占用时间很短的并发线程，具有一定的积极意义，但对于锁竞争激烈，单线程锁占用很长时间的并发程序，自旋
锁在自旋等待后，往往毅然无法获得对应的锁，不仅仅白白浪费了CPU时间，最终还是免不了被挂起的操作 ，反而浪费了系统的资源。在JDK1.6中，
Java虚拟机提供-XX:+UseSpinning参数来开启自旋锁，使用-XX:PreBlockSpin参数来设置自旋锁等待的次数。在JDK1.7开始，自旋锁的参数被
取消，虚拟机不再支持由用户配置自旋锁，自旋锁总是会执行，自旋锁次数也由虚拟机自动调整。&lt;/li&gt;
  &lt;li&gt;问题：
    &lt;ul&gt;
      &lt;li&gt;可能白占用CPU时间&lt;/li&gt;
      &lt;li&gt;死锁问题，自己占用锁，还在等待锁释放&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;32-阻塞锁&quot;&gt;3.2 阻塞锁&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进
入运行状态。JAVA中，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字（其中的重量锁），ReentrantLock，
Object.wait()\notify()&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;33-可重入锁&quot;&gt;3.3 可重入锁&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。  &lt;br /&gt;
在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;34-乐观锁和悲观锁&quot;&gt;3.4 乐观锁和悲观锁&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;悲观锁: 每次拿数据都上锁，如行锁、表锁、读锁、写锁&lt;/li&gt;
  &lt;li&gt;乐观锁: 每次拿数据都不上锁，只是在修改前验证下数据在此期间有无更新，如版本号控制&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;35-轮询锁和定时锁&quot;&gt;3.5 轮询锁和定时锁&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;由tryLock实现，与无条件获取锁模式相比，它们具有更完善的错误恢复机制。可避免死锁的发生：&lt;br /&gt;
boolean tryLock()：仅在调用时锁为空闲状态才获取该锁。如果锁可用，则获取锁，并立即返回值 true。
如果锁不可用，则此方法将立即返回值 false。
boolean tryLock(long time, TimeUnit unit) throws InterruptedException：
如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;36-显示锁和内置锁&quot;&gt;3.6 显示锁和内置锁&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;显示锁用Lock来定义、内置锁用synchronized。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;37-对象锁和类锁&quot;&gt;3.7 对象锁和类锁&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;对象锁是用于实例对象(可有多个实例对象)方法上的&lt;/li&gt;
  &lt;li&gt;类锁是作用于对象的静态方法和Class(一个类只有一个Class对象)对象上的&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;38-互斥锁&quot;&gt;3.8 互斥锁&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;互斥锁, 指的是一次最多只能有一个线程持有的锁。如Java的Lock&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;39-锁粗化&quot;&gt;3.9 锁粗化&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;将多个连续的锁操作合并成一个整体的锁&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;310-锁消除&quot;&gt;3.10 锁消除&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;通过逃逸分析，能证明堆上数据不会逃逸出当前线程，则认为是线程安全的，不必要加锁操作&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-java线程池&quot;&gt;4. java线程池&lt;/h2&gt;
&lt;h3 id=&quot;41-线程池实现类&quot;&gt;4.1 线程池实现类&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;      &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AbstractExecutorService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Executor&lt;/span&gt;
   &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;42-threadpoolexecutor构造参数说明&quot;&gt;4.2 ThreadPoolExecutor构造参数说明&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;    &lt;span class=&quot;c1&quot;&gt;// corePoolSize 核心线程数，当任务多于核心线程数时会进入缓冲阻塞队列workQueue&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// maximunPoolSize 线程池最大线程数&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// keepAliveTime 多于核心线程数的空闲线程最长存活时间量级与unit参数配合使用&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// unit 线程等待时间的单位级&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// workQueue 任务缓冲队列&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// threadFactory 线程工厂，用于创建线程&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// handler 表示拒接处理任务的策略有一下4种：&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//  - ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//  - ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//  - ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//  - ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;corePoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maximumPoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keepAliveTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;BlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;corePoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maximumPoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keepAliveTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;BlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThreadFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;corePoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maximumPoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keepAliveTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;BlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RejectedExecutionHandler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;corePoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maximumPoolSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keepAliveTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;BlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ThreadFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RejectedExecutionHandler&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;43-实现原理&quot;&gt;4.3 实现原理&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;线程池状态：
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;RUNNING&lt;/strong&gt;: 线程池初始化时就是RUNNING状态，表示线程池能够接受任务并处理，并且线程池中线程数默认为0(可以通过调用方法
   &lt;code class=&quot;highlighter-rouge&quot;&gt;prestartAllCoreThreads() #创建核心线程&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;prestartCoreThread() #创建一个核心线程&lt;/code&gt;来初始化线程数)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;SHUTDOWN&lt;/strong&gt;: 线程处于SHUTDOWN状态时,不接收新任务,但能处理已添加的任务;状态切换调用&lt;code class=&quot;highlighter-rouge&quot;&gt;shutdown()&lt;/code&gt;时从&lt;code class=&quot;highlighter-rouge&quot;&gt;RUNNING-&amp;gt; SHUTDOWN&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;STOP&lt;/strong&gt;: 线程处于STOP状态时，不接收新任务，不处理已添加任务，并会终止正在执行的任务;状态切换调用&lt;code class=&quot;highlighter-rouge&quot;&gt;shutdownNow()&lt;/code&gt;时从
&lt;code class=&quot;highlighter-rouge&quot;&gt;RUNNING or SHUTDOWN -&amp;gt; STOP&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;TIDYING&lt;/strong&gt;: 当所有任务已终止，任务数量为0时，线程池会进入TIDYING状态，并且会执行钩子函数&lt;code class=&quot;highlighter-rouge&quot;&gt;terminated()&lt;/code&gt;，用户可重载该方法
实现自己的业务逻辑;状态切换是所有任务终止就进入TIDYING状态&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;TERMINATED&lt;/strong&gt;: 线程池彻底终止状态;状态切换是TIDYING的钩子函数执行完毕后进入TERMINATED状态&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;任务执行过程
    &lt;ul&gt;
      &lt;li&gt;当任务提交给线程池时，线程首先判断当前池内线程数是否大于corePoolSize(核心线程数)，如果小于这值就会创建一个新的线程来执行该任务；&lt;/li&gt;
      &lt;li&gt;当线程数大于核心线程数时，则会尝试将任务放入缓冲队列(workQueue)内，若添加成功，则该任务会被等待的空闲线程取去执行，若添加失败，
则会尝试创建新的线程去执行该任务；&lt;/li&gt;
      &lt;li&gt;如果线程池内线程数达到了maximumPoolSize(最大线程数)时，则会采取handler(拒绝策略)处理&lt;/li&gt;
      &lt;li&gt;如果线程池内的线程数大于corePoolSize时，当线程空闲超时keepAliveTime时，线程将被终止，直到线程数等于corePoolSize；如果允许核心
线程数也有超时时间，则当核心线程数内的线程超时时也会被终止，直至线程数为0&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;线程池中的线程初始化
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;prestartCoreThread()&lt;/code&gt;：初始化一个核心线程&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;prestartAllCoreThreads()&lt;/code&gt;：初始化所有核心线程&lt;/li&gt;
      &lt;li&gt;初始化后线程会执行workQueue的&lt;code class=&quot;highlighter-rouge&quot;&gt;take()&lt;/code&gt;方法，该方法是阻塞的，直到有任务提交&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;任务缓存队列及排队策略
    &lt;ul&gt;
      &lt;li&gt;ArrayBlockingQueue：基于数组的FIFO阻塞队列,必须有最大容量的参数&lt;/li&gt;
      &lt;li&gt;LinkedBlockingQueue: 基于链表的FIFO阻塞队列,容量动态扩展&lt;/li&gt;
      &lt;li&gt;SynchronousQueue: 该队列不保存提交的任务，而是直接新建队列来执行任务&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;任务拒绝策略&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;    &lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;AbortPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;丢弃任务并抛出&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RejectedExecutionException&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;异常&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;DiscardPolicy&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：也是丢弃任务，但是不抛出异常&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;DiscardOldestPolicy&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;CallerRunsPolicy&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：由调用线程处理该任务&lt;/span&gt;
   &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;线程池的关闭
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shutdown()&lt;/code&gt;：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shutdownNow()&lt;/code&gt;: 立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;线程池容量动态调整
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setCorePoolSize()&lt;/code&gt;：设置核心池大小&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setMaximumPoolSize()&lt;/code&gt;：设置线程池最大能创建的线程数目大小&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;44-executors&quot;&gt;4.4 Executors&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;newFixedThreadPool: 定容量的线程池，核心线程数与最大线程数相等&lt;/li&gt;
  &lt;li&gt;newSingleThreadExecutor: 单线程线程池，线程池内核心线程数与最大线程数为1&lt;/li&gt;
  &lt;li&gt;newCachedThreadPool: 无线大小线程池，核心线程数为0，最大线程数为&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer.MAX_VALUE&lt;/code&gt;, 缓冲队列为&lt;code class=&quot;highlighter-rouge&quot;&gt;SynchronousQueue&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;newScheduledThreadPool：创建一个ScheduledThreadPoolExecutor定时执行线程池,最大线程数为&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer.MAX_VALUE&lt;/code&gt;,内部是
一个DelayedWorkQueue实现&lt;/li&gt;
  &lt;li&gt;newSingleThreadScheduledExecutor: 创建一个ScheduledThreadPoolExecutor定时执行线程池,最大线程数为&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer.MAX_VALUE&lt;/code&gt;,
内部是一个DelayedWorkQueue实现&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5-abstractqueuedsynchronizer&quot;&gt;5. AbstractQueuedSynchronizer&lt;/h2&gt;
&lt;p&gt;内部类：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ConditionObject：&lt;/li&gt;
  &lt;li&gt;Node：存放线程信息队列&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;51-aqs之reentrantlock独占锁源码分析&quot;&gt;5.1 AQS之ReentrantLock独占锁源码分析&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer&quot;&gt;AbstractQueuedSynchronizer独占锁&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ReentrantLock.lock()&lt;/code&gt;保证在&lt;code class=&quot;highlighter-rouge&quot;&gt;ReentrantLock.unlock()&lt;/code&gt;之间的代码只有一个线程在执行；ReentrantLock为可重入锁，它有一个与
锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放。&lt;/li&gt;
  &lt;li&gt;内部类&lt;code class=&quot;highlighter-rouge&quot;&gt;Syn&lt;/code&gt;实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;AbstractQueuedSynchronizer&lt;/code&gt;接口&lt;/li&gt;
  &lt;li&gt;构造方法有公平锁和非公平锁，公平锁与非公平锁的区别在于公平锁在尝试获取锁时会放入等待队列的后面，获取锁的顺序是按先后顺序执行的，
而非公平锁在尝试获取锁时首先会去尝试获取锁，若获取失败在进入等待队列按顺序执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;52-aqs之countdownlatch共享锁源码分析&quot;&gt;5.2 AQS之CountDownLatch共享锁源码分析&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/java8-abstractqueuedsynchronizer&quot;&gt;AbstractQueuedSynchronizer共享锁&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CountDownLatch.countDown()&lt;/code&gt;实现锁计数-1，直到减至0是，唤醒&lt;code class=&quot;highlighter-rouge&quot;&gt;CountDownLatch.await()&lt;/code&gt;等待线程&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;53-公平锁和非公平锁&quot;&gt;5.3 公平锁和非公平锁&lt;/h3&gt;
&lt;p&gt;公平锁是严格按照FIFO队列获得锁，但带来了大量的线程切换的消耗，非公平锁极大的降低了线程切换带来的消耗，虽然可能造成线程饥饿的情况，
   但也提高了吞吐量。&lt;/p&gt;

&lt;h2 id=&quot;6-synchronized与lock比较&quot;&gt;6. synchronized与Lock比较&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;是JVM层面实现的’重量级锁’，可通过监控工具监控&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;的锁定，而且代码出现异常时会自动释放锁&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Lock&lt;/code&gt;是纯JAVA实现的，为多种实现留下空间，可以实现不同的调度算法、性能特性或者锁定语义，&lt;code class=&quot;highlighter-rouge&quot;&gt;Lock&lt;/code&gt;必须自己手动的释放锁
形如&lt;code class=&quot;highlighter-rouge&quot;&gt;finally{lock.unlock();}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;当锁竞争激烈时用&lt;code class=&quot;highlighter-rouge&quot;&gt;Lock&lt;/code&gt;,锁竞争较弱时用&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;7-阻塞队列blockingqueue&quot;&gt;7. 阻塞队列BlockingQueue&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;阻塞队列是一个FIFO队列&lt;/li&gt;
  &lt;li&gt;主要方法&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Ops&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Throws Exception&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Special Value&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Blocks Times Out&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Insert&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;add(o)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;offer(o)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;put(o) &amp;amp; offer(o, timeout, timeUnit)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Remove&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;remove(o)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;poll()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;take()	&amp;amp; poll(timeout, timeUnit)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Examine&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;element()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;peek()&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;主要实现
    &lt;ul&gt;
      &lt;li&gt;ArrayBlockingQueue：基于数组的有界阻塞队列，必须指定长度&lt;/li&gt;
      &lt;li&gt;LinkedBlockingQueue: 基于链表的有界阻塞队列，长度可指定也可动态扩张，默认长度为&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;SynchronousQueue: 无缓冲区的阻塞队列，&lt;code class=&quot;highlighter-rouge&quot;&gt;put()&lt;/code&gt;要阻塞等待&lt;code class=&quot;highlighter-rouge&quot;&gt;take()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;PriorityBlockingQueue: 优先级阻塞队列，队列元素必须实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;接口，基于数组，自动扩展长度&lt;/li&gt;
      &lt;li&gt;DelayQueue：一个使用优先级队列实现的无界阻塞队列&lt;/li&gt;
      &lt;li&gt;LinkedTransferQueue：一个由链表结构组成的无界阻塞队列&lt;/li&gt;
      &lt;li&gt;LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;注意&lt;br /&gt;
   如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且使用offer方法时，该方法永远返回true。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;8-concurrentlinkedqueue&quot;&gt;8. ConcurrentLinkedQueue&lt;/h2&gt;
&lt;p&gt;非阻塞线程安全的FIFO队列，基于单向链表实现，循环CAS操作实现，由于是根据Node.NEXT是否为NULL来判断是否为TAIL节点，因此
   队列的元素值不可为NULL。&lt;/p&gt;</content><author><name>Crab2Died</name></author><category term="Java" /><category term="Concurrent" /><summary type="html">1. JAVA与线程 1.1 线程的实现 实现方式:使用内核线程实现、 使用用户线程实现和使用用户线程加轻量级进程混合实现. JDK1.2之前是基于用户线程实现的，JDK1.2及以后是基于操作系统原生线程模型实现的. 1.2 Java线程调度 线程调度是指系统为线程分配处理器使用权的过程,主要调度方式有两种,分别是协同式线程调度(Cooperative Threads-Scheduling) 和抢占式线程调度(Preemptive ThreadsScheduling) 协同式线程调度:线程的执行时间由线程本身来控制,线程把自己的工作执行完了之后,要主动通知系统切换到另外一个线程上; 优点是实现简单,缺点是线程执行时间不可控制,容易线程阻塞 每个线程将由系统来分配执行时间,线程的切换不由线程本身来决定(在Java中,Thread.yield()可以让出执行时间,但是要获取执行时 间的话,线程本身是没有什么办法的);优点是线程的执行时间是系统可控的,也不会有一个线程导致整个进程阻塞的问题. JAVA线程有10个优先级(Thread.MIN_PRIORITY至Thread.MAX_PRIORITY) 1.3 线程转换状态 JAVA线程定义了6个状态: 新建(New):创建后尚未启动的线程处于这种状态. 运行(Runable):Runable包括了操作系统线程状态中的Running和Ready,也就是处于此状态的线程有可能正在执行,也有可能正在 等待着CPU为它分配执行时间. 无限期等待(Waiting):处于这种状态的线程不会被分配CPU执行时间,它们要等待被 其他线程显式地唤醒. 以下方法会让线程陷入无限期的等待状态: ● 没有设置Timeout参数的Object.wait()方法. ● 没有设置Timeout参数的Thread.join()方法. ● LockSupport.park()方法. 限期等待(Timed Waiting):处于这种状态的线程也不会被分配CPU执行时间,不过无须等待被其他线程显式地唤醒,在一定时间之后 它们会由系统自动唤醒. 以下方法会让线程进入限期等待状态: ● Thread.sleep()方法. ● 设置了Timeout参数的Object.wait()方法. ● 设置了Timeout参数的Thread.join()方法. ● LockSupport.parkNanos()方法. ● LockSupport.parkUntil()方法 阻塞(Blocked):该状态程序在等待获取一个排他锁，程序在同步时会在该状态 结束(Terminated):已终止线程的线程状态,线程已经结束执行. 线程状态转换关系图 2. 线程安全与锁优化 2.1 JAVA中的线程安全 共享数据分类 不可变(Immutable):不可变对象一定是线程安全的,典型的final 绝对线程安全: 相对线程安全: java大部分的线程安全都是相对线程安全的 线程兼容: 线程对立:</summary></entry><entry><title type="html">Java Collection Frame</title><link href="https://crab2died.github.io/jekyll-blog/content/java/2018/06/15/java-collection-frame.html" rel="alternate" type="text/html" title="Java Collection Frame" /><published>2018-06-15T13:15:27+08:00</published><updated>2018-06-15T13:15:27+08:00</updated><id>https://crab2died.github.io/jekyll-blog/content/java/2018/06/15/java-collection-frame</id><content type="html" xml:base="https://crab2died.github.io/jekyll-blog/content/java/2018/06/15/java-collection-frame.html">&lt;h2 id=&quot;1-java集合框架图&quot;&gt;1. JAVA集合框架图&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;集合框架
   &lt;img src=&quot;https://raw.githubusercontent.com/Crab2died/jdepth/master/src/main/java/com/github/jvm/collections/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.jpg&quot; alt=&quot;集合框架&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;集合框架-简图
   &lt;img src=&quot;https://raw.githubusercontent.com/Crab2died/jdepth/master/src/main/java/com/github/jvm/collections/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-%E7%AE%80%E5%9B%BE.jpg&quot; alt=&quot;集合框架-简图&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-arraylistlinkedlistvectorstack&quot;&gt;2. ArrayList、LinkedList、Vector、Stack&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;都是java的可存储重复元素的集合容器,都实现了Collection、List接口&lt;/li&gt;
  &lt;li&gt;ArrayList是基于数组的可动态扩展的、可存储重复元素的、有默认顺序的集合，非线程安全的，最大元素个数为&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer.MAX_VALUE&lt;/code&gt;个
由于是基于数组的所以add(E)、get(i)效率较高，set(i,E)、remove(i)、add(i,E)效率较低&lt;/li&gt;
  &lt;li&gt;LinkedList是基于双向链表的可动态扩展的、可存储重复元素的、非线程安全的有序集合。
由于是基于链表的所以add(E)、add(i,E)、set(i,E)、remove(i)效率较高，get(i)效率较低&lt;/li&gt;
  &lt;li&gt;Vector是基于数组的可动态扩展的、可存储重复元素的、线程安全的有序集合
由于是线程安全的所以效率比上诉的都要低&lt;/li&gt;
  &lt;li&gt;Stack(栈),继承了Vector,只有push(入栈)、pop(出栈)、peek(查看)等方法实现&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-hashsetlinkedhashsettreeset&quot;&gt;3. HashSet、LinkedHashSet、TreeSet&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;都是java的不可存储重复元素的集合容器,都实现了Collection、Set接口&lt;/li&gt;
  &lt;li&gt;HashSet是不重复的(hashcode去重)、非线程安全的无序集合
只能放一个null&lt;/li&gt;
  &lt;li&gt;LinkedHashSet是不重复的(hashcode去重)、非线程安全的有序集合&lt;/li&gt;
  &lt;li&gt;TreeSet是SortedSet唯一实现类，TreeSet可实现自定义排序(实现Comparable接口)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-hashmaphashtableconcurrenthashmapidentityhashmap&quot;&gt;4. HashMap、HashTable、ConcurrentHashMap、IdentityHashMap&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;都是存储形如key-value集合的容器，都实现了Map接口&lt;/li&gt;
  &lt;li&gt;HashMap是非线程安全的、按key值得hashcode去重的、无序的集合, 能接受key为null&lt;/li&gt;
  &lt;li&gt;HashTable与HashTable类似，区别在于其实现了同步，效率也相较于HashMap低，不能接受key为null的情况&lt;/li&gt;
  &lt;li&gt;ConcurrentHashMap是线程安全的、引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需
要等到迭代完成才能访问map。简而言之在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map,
所以ConcurrentHashMap效率高于HashTable, 不能接受key为null的情况 &lt;br /&gt;
ConcurrentHashMap实现锁分段技术是通过可重入锁ReentrantLock实现Segment[]分锁，每个Segment内部存放一个或多个HashEntry[]
每个HashEntry又是一个链表，具体的数据结构如图：&lt;br /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/Crab2died/jdepth/master/src/main/java/com/github/jvm/collections/ConcurrentHashMap.jpg&quot; alt=&quot;ConcurrentHashMap结构图&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;IdentityHashMap基于数组的、区别于HashMap的是比较key值是比较引用相等(形如&lt;code class=&quot;highlighter-rouge&quot;&gt;object1 == object2&lt;/code&gt;)的，HashMap是equals()
判断是否相等的，能接受key为null&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Crab2Died</name></author><category term="Java" /><category term="Collection" /><summary type="html">1. JAVA集合框架图 集合框架 集合框架-简图</summary></entry><entry><title type="html">Ruby Install With Source On CentOS</title><link href="https://crab2died.github.io/jekyll-blog/content/ruby/2018/06/14/ruby-install-on-centos.html" rel="alternate" type="text/html" title="Ruby Install With Source On CentOS" /><published>2018-06-14T12:45:27+08:00</published><updated>2018-06-14T12:45:27+08:00</updated><id>https://crab2died.github.io/jekyll-blog/content/ruby/2018/06/14/ruby-install-on-centos</id><content type="html" xml:base="https://crab2died.github.io/jekyll-blog/content/ruby/2018/06/14/ruby-install-on-centos.html">&lt;h2 id=&quot;1-install-openssl&quot;&gt;1. Install OpenSSL&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.openssl.org/source/&quot;&gt;Download OpenSSL Source&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Install OpenSSL&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt; &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-zxvf&lt;/span&gt; openssl-1.1.1-pre7.tar.gz
 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;openssl-1.1.1-pre7
 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./config &lt;span class=&quot;nt&quot;&gt;-fPIC&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/local/openssl enable-shared
 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./config &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt;
 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
 &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;Check install&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt; &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;openssl version
 OpenSSL 1.0.2k-fips  26 Jan 2017
 &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;2-install-ruby&quot;&gt;2. Install Ruby&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruby-lang.org/en/downloads/&quot;&gt;Download Ruby Source&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Install Ruby&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt; &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-zxvf&lt;/span&gt; ruby-2.5.1.tar.gz
 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;ruby-2.5.1
 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./configure &lt;span class=&quot;nt&quot;&gt;--prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/local/ruby &lt;span class=&quot;nt&quot;&gt;--with-opessl-dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/local/openssl     // important
 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; make &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
 &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;Configure environment variable&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt; &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vi /etc/profile
 
 append -&amp;gt; &lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/local/ruby/bin:&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;
 
 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; /etc/profile
 &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;Check install&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt; &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ruby &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt;
 ruby 2.5.1p57 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2018-03-29 revision 63029&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;x86_64-linux]
 
 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gem &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt;
 2.7.6
 &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>Crab2Died</name></author><category term="Ruby Install" /><category term="CentOS" /><summary type="html">1. Install OpenSSL Download OpenSSL Source Install OpenSSL $ tar -zxvf openssl-1.1.1-pre7.tar.gz $ cd openssl-1.1.1-pre7 $ ./config -fPIC --prefix=/usr/local/openssl enable-shared $ ./config -t $ make &amp;amp;&amp;amp; make install Check install $ openssl version OpenSSL 1.0.2k-fips 26 Jan 2017 2. Install Ruby Download Ruby Source Install Ruby $ tar -zxvf ruby-2.5.1.tar.gz $ cd ruby-2.5.1 $ ./configure --prefix=/usr/local/ruby --with-opessl-dir=/usr/local/openssl // important $ make &amp;amp;&amp;amp; make install Configure environment variable $ vi /etc/profile append -&amp;gt; export PATH=/usr/local/ruby/bin:$PATH $ source /etc/profile Check install $ ruby -v ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-linux] $ gem -v 2.7.6</summary></entry><entry><title type="html">JAVA Monitor Tools</title><link href="https://crab2died.github.io/jekyll-blog/content/java/2018/06/14/java-monitor-tools.html" rel="alternate" type="text/html" title="JAVA Monitor Tools" /><published>2018-06-14T12:45:27+08:00</published><updated>2018-06-14T12:45:27+08:00</updated><id>https://crab2died.github.io/jekyll-blog/content/java/2018/06/14/java-monitor-tools</id><content type="html" xml:base="https://crab2died.github.io/jekyll-blog/content/java/2018/06/14/java-monitor-tools.html">&lt;h2 id=&quot;一-jpsjvm-process-status-tool&quot;&gt;一. jps(JVM Process Status Tool)&lt;/h2&gt;
&lt;h3 id=&quot;1-介绍&quot;&gt;1. 介绍&lt;/h3&gt;
&lt;p&gt;类似UNIX的ps命令，列出虚拟机正在运行的进程信息&lt;/p&gt;

&lt;h3 id=&quot;2-参数&quot;&gt;2. 参数&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;-q: 只输出进程ID&lt;/li&gt;
  &lt;li&gt;-m: 输出主类启动时的参数&lt;/li&gt;
  &lt;li&gt;-l: 输出主类全名，如果是jar则输出jar路径&lt;/li&gt;
  &lt;li&gt;-v: 输出虚拟机启动时的JVM参数&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;二-jstatjvm-statistics-monitoring-tool&quot;&gt;二. jstat(JVM Statistics Monitoring Tool)&lt;/h2&gt;
&lt;h3 id=&quot;1-介绍-1&quot;&gt;1. 介绍&lt;/h3&gt;
&lt;p&gt;用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程虚拟机进程中的类装载、 内存、 垃圾收集、 JIT编译等运行数据&lt;/p&gt;

&lt;h3 id=&quot;2-格式&quot;&gt;2. 格式&lt;/h3&gt;
&lt;p&gt;jstat[option vmid[interval[s|ms][count]]]
   如&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jstat -class 14232(PID) 520(采样率) 4(采样次数)&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-参数&quot;&gt;3. 参数&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;-class: 监控类加载数量、卸载数量、总空间以及加载所用时间&lt;/li&gt;
  &lt;li&gt;-gc: 监控java堆状态，包括Eden区，2个survivor区，老年代，永久代的容量、已用空间、GC时间合计等&lt;/li&gt;
  &lt;li&gt;-gccapacity: 与-gc基本相同，但主要关注java堆各个区域使用到的最大、最小空间&lt;/li&gt;
  &lt;li&gt;-gcutil: 与-gc基本相同，但主要关注java堆各个区域使用占比&lt;/li&gt;
  &lt;li&gt;-gccase: 与-gcutil一样，但会额外输出上一次GC的原因&lt;/li&gt;
  &lt;li&gt;-gcnew: 监控新生代GC状态&lt;/li&gt;
  &lt;li&gt;-gcnewcapacity: 与-gcnew基本相同，但主要关注的是使用到的最大、最小空间&lt;/li&gt;
  &lt;li&gt;-gcold: 监控老年代GC状态&lt;/li&gt;
  &lt;li&gt;-gcoldcapacity: 与-gcold基本相同，但主要关注的是使用道的最大、最小空间&lt;/li&gt;
  &lt;li&gt;-gcpermcapacity: 输出永久带使用到的最大、最小空间&lt;/li&gt;
  &lt;li&gt;-compiler: 输出JIT编译过的方法、耗时等信息&lt;/li&gt;
  &lt;li&gt;-printcompilation: 输出已被JIT编译过的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三-jinfoconfiguration-info-for-java&quot;&gt;三. jinfo(Configuration Info for Java)&lt;/h2&gt;
&lt;h3 id=&quot;1-介绍-2&quot;&gt;1. 介绍&lt;/h3&gt;
&lt;p&gt;实时地查看和调整虚拟机各项参数&lt;/p&gt;

&lt;h3 id=&quot;2-格式-1&quot;&gt;2. 格式&lt;/h3&gt;
&lt;p&gt;jinfo [option] pid 如 &lt;code class=&quot;highlighter-rouge&quot;&gt;jinfo -flags 14232&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-参数-1&quot;&gt;3. 参数&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;-flag &lt;name&gt;: to print the value of the named VM flag(输出JVM参数名为name的参数信息)&lt;/name&gt;&lt;/li&gt;
  &lt;li&gt;-flag +/-&lt;name&gt;: to enable or disable the named VM flag(添加或除去JVM参数名为name的参数)&lt;/name&gt;&lt;/li&gt;
  &lt;li&gt;-flag &lt;name&gt;=&lt;value&gt;: to set the named VM flag to the given value(设置JVM参数，入-Xmx=1024m)&lt;/value&gt;&lt;/name&gt;&lt;/li&gt;
  &lt;li&gt;-flags: to print VM flags(输出JVM启动参数信息)&lt;/li&gt;
  &lt;li&gt;-sysprops: to print Java system properties(输出&lt;code class=&quot;highlighter-rouge&quot;&gt;System.getProperties()&lt;/code&gt;信息)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四-jmapmemory-map-for-java&quot;&gt;四. jmap(Memory Map for Java)&lt;/h2&gt;
&lt;h3 id=&quot;1-介绍-3&quot;&gt;1. 介绍&lt;/h3&gt;

&lt;p&gt;命令用于生成堆转储快照(一般称为heapdump或dump文件)&lt;br /&gt;
   其他生成dump文件方式:通过参数&lt;code class=&quot;highlighter-rouge&quot;&gt;-XX：+HeapDumpOnOutOfMemoryError&lt;/code&gt;OOM时生成、&lt;code class=&quot;highlighter-rouge&quot;&gt;-XX：+HeapDumpOnCtrlBreak&lt;/code&gt;通过
   [Ctrl]+[Break]键让虚拟机生成dump文件、或者Linux通过命令kill -3 pid也能拿到dump&lt;/p&gt;
&lt;h3 id=&quot;2-格式-2&quot;&gt;2. 格式&lt;/h3&gt;
&lt;p&gt;jmap [option] vmid&lt;/p&gt;

&lt;h3 id=&quot;3-参数-2&quot;&gt;3. 参数&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;-dump: 生成java堆转存快照, 格式 -dump:[live, ],format=b,file=&lt;filename&gt;, live表示是否只导出存活的对象&lt;/filename&gt;&lt;/li&gt;
  &lt;li&gt;-finalizerinfo: 显示在F-Queen里面等待Finalizer线程执行finalize()方法的对象，只在Linux/Solaris平台有效&lt;/li&gt;
  &lt;li&gt;-heap: 显示java堆详细信息，如使用哪种GC回收器，参数配置、分代状况等信息，只在Linux/Solaris平台有效&lt;/li&gt;
  &lt;li&gt;-histo: 显示堆中对象统计信息，包括类、实例数量及合计容量等&lt;/li&gt;
  &lt;li&gt;-permstat: 以ClassLoader为统计口径显示永久带内存状态，只在Linux/Solaris平台有效&lt;/li&gt;
  &lt;li&gt;-F: 当-dump没响应时，使用-F强制生成dump文件，只在Linux/Solaris平台有效&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;五-jhatjvm-heap-analysis-tool&quot;&gt;五. jhat(JVM Heap Analysis Tool)&lt;/h2&gt;
&lt;h3 id=&quot;1-介绍-4&quot;&gt;1. 介绍&lt;/h3&gt;
&lt;p&gt;分析jmap生成的堆转储快照(dump文件)&lt;/p&gt;

&lt;h3 id=&quot;2-格式-3&quot;&gt;2. 格式&lt;/h3&gt;
&lt;p&gt;jhat [-port 7001] &lt;dumpfile&gt;&lt;/dumpfile&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-参数-3&quot;&gt;3. 参数&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;-port: server端口，可通过host:port访问&lt;/li&gt;
  &lt;li&gt;
    &lt;file&gt;: dump文件
&lt;/file&gt;
  &lt;/li&gt;
  &lt;li&gt;-J&lt;flag&gt;: 运行参数,如`-J-mx512m`&lt;/flag&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;六-jstackstack-trace-for-java&quot;&gt;六. jstack(Stack Trace for Java)&lt;/h2&gt;
&lt;h3 id=&quot;1-介绍-5&quot;&gt;1. 介绍&lt;/h3&gt;

&lt;p&gt;用于生成虚拟机当前时刻的线程快照(一般称为threaddump或者javacore文件)&lt;br /&gt;
   线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，
   如线程间死锁、 死循环、 请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。 线程出现停顿的时候通过
   jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源&lt;/p&gt;
&lt;h3 id=&quot;2-格式-4&quot;&gt;2. 格式&lt;/h3&gt;
&lt;p&gt;jstack [option] vmid 如&lt;code class=&quot;highlighter-rouge&quot;&gt;jstack -l 14232&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-参数-4&quot;&gt;3. 参数&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;-F: 当正常请求无响应时，强制输出线程堆栈&lt;/li&gt;
  &lt;li&gt;-l: 除堆栈外，显示关于锁的附加信息&lt;/li&gt;
  &lt;li&gt;-m: 如果调用到本地方法时，显示C/C++堆栈信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-日志分析&quot;&gt;4. 日志分析&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;线程分为New、Runnable、Running、Waiting、Timed_Waiting、Blocked、Dead等状态
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;New&lt;/strong&gt;: 当线程对象创建时存在的状态，此时线程不可能执行；&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Runnable&lt;/strong&gt;：当调用thread.start()后，线程变成为Runnable状态。只要得到CPU，就可以执行；&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Running&lt;/strong&gt;：线程正在执行；&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Waiting&lt;/strong&gt;：执行thread.join()或在锁对象调用obj.wait()等情况就会进该状态，表明线程正处于等待某个资源或条件发生来唤醒自己；&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Timed_Waiting&lt;/strong&gt;：执行Thread.sleep(long)、thread.join(long)或obj.wait(long)等就会进该状态，与Waiting的区别在于Timed_Waiting的等待有时间限制；&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Blocked&lt;/strong&gt;：如果进入同步方法或同步代码块，没有获取到锁，则会进入该状态；&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Dead&lt;/strong&gt;：线程执行完毕，或者抛出了未捕获的异常之后，会进入dead状态，表示该线程结束&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;其次，对于jstack日志，我们要着重关注如下关键信息
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Deadlock&lt;/strong&gt;：表示有死锁&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Waiting on condition&lt;/strong&gt;：等待某个资源或条件发生来唤醒自己。具体需要结合jstacktrace来分析，比如线程正在sleep，网络读写繁忙而等待&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Blocked&lt;/strong&gt;：阻塞&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Waiting on monitor entry&lt;/strong&gt;：在等待获取锁&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;in Object.wait()&lt;/strong&gt;：获取锁后又执行obj.wait()放弃锁&lt;/li&gt;
      &lt;li&gt;对于Waiting on monitor entry 和 inObject.wait()的详细描述：Monitor是 Java中用以实现线程之间的互斥与协作的主要手段，
它可以看成是对象或者Class的锁。每一个对象都有，也仅有一个 monitor。从下图中可以看出，每个 Monitor在某个时刻，只能被一个
线程拥有，该线程就是 “Active Thread”，而其它线程都是 “Waiting Thread”，分别在两个队列 “Entry Set”和 “Wait Set”里面
等候。在 “Entry Set”中等待的线程状态是”Waiting for monitor entry”，而在 “Wait Set”中等待的线程状态是 “in Object.wait()”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;5-附录&quot;&gt;5. 附录&lt;/h3&gt;
&lt;p&gt;在JDK1.5中在&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Thread&lt;/code&gt;类中新增了&lt;code class=&quot;highlighter-rouge&quot;&gt;getAllStackTraces()&lt;/code&gt;方法获取虚拟机所有的线程&lt;code class=&quot;highlighter-rouge&quot;&gt;StackTraceElement&lt;/code&gt;
   对象，实现了大部分jstack功能，实际项目中可页面展示&lt;/p&gt;

&lt;h2 id=&quot;七-visualvmall-in-one-java-troubleshooting-tool&quot;&gt;七. VisualVM(All-in-One Java Troubleshooting Tool)&lt;/h2&gt;
&lt;h3 id=&quot;介绍&quot;&gt;介绍&lt;/h3&gt;
&lt;p&gt;是到目前为止随JDK发布的功能最强大的运行监视和故障处理程序，并且可以预见在未来一段时间内都是官方主力发展的虚拟机故障处理工具。
  官方在VisualVM的软件说明中写上了“All-in-One”的描述字样，预示着它除了运行监视、 故障处理外，还提供了很多其他方面的功能。&lt;/p&gt;

&lt;h3 id=&quot;远程监控&quot;&gt;远程监控&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1、远程服务器启动jstatd服务
创建配置文件jstatd.policy内容为
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; {  
   permission java.security.AllPermission;  
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;启动服务:&lt;code class=&quot;highlighter-rouge&quot;&gt;jstatd -J-Djava.security.policy=jstatd.policy -p 8701&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;2、启动应用参数
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-Dcom.sun.management.jmxremote=true 
-Dcom.sun.management.jmxremote.port=9090 
-Dcom.sun.management.jmxremote.ssl=false 
-Dcom.sun.management.jmxremote.authenticate=false
-Djava.rmi.server.hostname=192.168.0.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;3、启动jvisualvm,操作步骤:&lt;br /&gt;
远程 -&amp;gt; 添加远程主机 -&amp;gt; 添加JMX链接&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;八-案列&quot;&gt;八. 案列&lt;/h2&gt;
&lt;h3 id=&quot;1-利用jstack调试线程堆栈信息&quot;&gt;1. 利用jstack调试线程堆栈信息&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;jps得到PID，如14232&lt;/li&gt;
  &lt;li&gt;查看进程PID的线程耗时情况,命令&lt;code class=&quot;highlighter-rouge&quot;&gt;ps -Lfp pid&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;top -Hp pid&lt;/code&gt;找到最耗时的线程ID 如14253&lt;/li&gt;
  &lt;li&gt;获取线程ID16进制编码&lt;code class=&quot;highlighter-rouge&quot;&gt;print &quot;%x\n&quot; 14253&lt;/code&gt;为37ad&lt;/li&gt;
  &lt;li&gt;用jstack获取线程堆栈信息&lt;code class=&quot;highlighter-rouge&quot;&gt;jstack 14232 |grep 37ad&lt;/code&gt;打印如下信息:&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;VM Periodic Task Thread&quot; os_prio=0 tid=0x00007f772c00f800 nid=0x37ad waiting on condition &lt;/code&gt;&lt;br /&gt;
通过该日志分析表示该线程在等待某个资源来唤醒&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Crab2Died</name></author><category term="Java Monitor" /><summary type="html">一. jps(JVM Process Status Tool) 1. 介绍 类似UNIX的ps命令，列出虚拟机正在运行的进程信息 2. 参数 -q: 只输出进程ID -m: 输出主类启动时的参数 -l: 输出主类全名，如果是jar则输出jar路径 -v: 输出虚拟机启动时的JVM参数</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="https://crab2died.github.io/jekyll-blog/content/demo/2018/06/13/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2018-06-13T21:54:27+08:00</published><updated>2018-06-13T21:54:27+08:00</updated><id>https://crab2died.github.io/jekyll-blog/content/demo/2018/06/13/welcome-to-jekyll</id><content type="html" xml:base="https://crab2died.github.io/jekyll-blog/content/demo/2018/06/13/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name>Crab2Died</name></author><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry></feed>